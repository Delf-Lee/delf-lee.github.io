{"meta":{"title":"Delf's blog","subtitle":null,"description":null,"author":"Delf","url":"https://delf-lee.github.io"},"pages":[{"title":"","date":"2018-08-28T18:02:18.186Z","updated":"2018-08-28T17:22:09.979Z","comments":true,"path":"index.html","permalink":"https://delf-lee.github.io/index.html","excerpt":"","text":"this is index.md"},{"title":"","date":"2018-08-26T06:37:25.404Z","updated":"2018-08-26T06:37:25.404Z","comments":true,"path":"about/index.html","permalink":"https://delf-lee.github.io/about/index.html","excerpt":"","text":""},{"title":"","date":"2018-10-19T17:00:09.328Z","updated":"2018-09-13T10:55:40.381Z","comments":true,"path":"draft/draft.html","permalink":"https://delf-lee.github.io/draft/draft.html","excerpt":"","text":""}],"posts":[{"title":"IntelliJ에서 gradle을 이용하여 Spring MVC 프로젝트 만들기","slug":"post/start-intellij-gradle-springmvc-project","date":"2018-11-24T02:52:50.000Z","updated":"2018-11-24T16:01:51.824Z","comments":true,"path":"post/start-intellij-gradle-springmvc-project/","link":"","permalink":"https://delf-lee.github.io/post/start-intellij-gradle-springmvc-project/","excerpt":"","text":"들어가기 전목표 IntelliJ에서 gradle을 이용하여 Spring MVC 프로젝트 만들기 Tomcat과 연동하여 Hello world 띄우기 과정 IntellJ에서 Gradle 프로젝트 생성 # Spring MVC project 설정 # 방법1. IntelliJ에서 제공하는 Spring MVC 라이브러리 다운로드 # 방법2. Gradle을 이용한 의존성 주입 # Artifacts 설정 # 설정 파일 변경(web.xml) # index.jsp 작성 # Tomcat 설정 # 구현 환경 macOS X (10.13.6) IntelliJ IDEA (2018.3) Spring MVC (4.3.18, 5.0.8) Gradle (4.6) Tomcat (8.5.32) 1. IntellJ에서 Gradle 프로젝트 생성Gradle - Java 선택 GroupId, ArtifactId 설정 Gradle 설정. 프로젝트 명, 경로 설정 만들어진 프로젝트 구성 2. Spring MVC project 설정방법1. IntelliJ에서 제공하는 Spring MVC 라이브러리 다운로드좌측 상단의 프로젝트명 우클릭 - [Add Framework Support…] 선택 [Spring] - [Spring MVC] 선택Download를 선택하여 직접 라이브러리를 다운로드합니다. 버전은 4.3.18 입니다. 추가된 Spring MVC 라이브러리 확인프로젝트의 root 디렉토리 아래에 /lib이 생성 되었고, 거기에 다운로드 받은 라이브러리가 저장된 것을 확인할 수 있습니다. 그리고 IntelliJ에서 자동으로 /web과 /web/WEB-INF, 설정파일을 자동을 생성해 줍니다. 방법2. Gradle을 이용한 의존성 주입저는 gradle로 의존성을 주입하여 프로젝트를 관리했습니다. build.gradle 파일에 Spring MVC 의존성 주입Spring MVC의 버전은 https://mvnrepository.com에서 5.0 중 가장 많이 쓰이는 것을 사용하였습니다. 참고: MVN repository - Spring Web MVM// https://mvnrepository.com/artifact/org.springframework/spring-webmvccompile group: 'org.springframework', name: 'spring-webmvc', version: '5.0.8.RELEASE' Gradle import 후 프로젝트 구성아까와는 달리 External Libraries 아래에 Spring MVC와 dependency 라이브러리들이 설치된 것을 확인할 수 있습니다. build.gradle plugins &#123; id 'java'&#125;group 'com.delf.spring'version '1.0-SNAPSHOT'sourceCompatibility = 1.8repositories &#123; mavenCentral()&#125;dependencies &#123; testCompile group: 'junit', name: 'junit', version: '4.12' compile group: 'org.springframework', name: 'spring-webmvc', version: '5.0.8.RELEASE'&#125; Framework Support 추가 방법1.에서와 같이 [Add Framework Support…]를 선택하여 [Spring] - [Spring MVC]를 체크해줍니다. 그리고 Download가 아닌 [Use library]를 선택하면, 아까 설치된 Spring MVC 라이브러라가 자동으로 연결됩니다. 추가가 완료되면, 라이브러리에 맞춰 설정 파일과 index.jsp가 생성된 것을 확인할 수 있습니다.3. Artifacts 설정다음 과정은 자동으로 구성될 수 있습니다만, 설정되지 않았다면 다음과 같은 에러가 발생합니다.Connected to serverArtifact com.delf.spring.spring-store:war exploded: Artifact is being deployed, please wait...경고 [RMI TCP Connection(2)-127.0.0.1] org.apache.tomcat.util.descriptor.web.WebXml.setVersion Unknown version string [4.0]. Default version will be used.심각 [RMI TCP Connection(2)-127.0.0.1] org.apache.catalina.core.StandardContext.startInternal One or more listeners failed to start. Full details will be found in the appropriate container log file심각 [RMI TCP Connection(2)-127.0.0.1] org.apache.catalina.core.StandardContext.startInternal Context [/com_delf_spring_spring_store_war_exploded] startup failed due to previous errorsArtifact com.delf.spring.spring-store:war exploded: Error during artifact deployment. See server log for details.정보 [localhost-startStop-1] org.apache.catalina.startup.HostConfig.deployDirectory Deploying web application directory [/usr/local/Cellar/tomcat@8/8.5.32/libexec/webapps/manager]정보 [localhost-startStop-1] org.apache.catalina.startup.HostConfig.deployDirectory Deployment of web application directory [/usr/local/Cellar/tomcat@8/8.5.32/libexec/webapps/manager] has finished in [55] ms Spring MVC 라이브러리에 대한 Artifact를 추가합니다. [File] - [Project Structure] - [Artifacts] Project Structure 설정 단축키 (⌘ + ;) 우측에 있는 Spring과 Spring MVC 라이브러리 더블클릭 추가 완료 4. 설정 파일 변경(web.xml)변경&lt;url-pattern&gt;*.form&lt;/url-pattern&gt;을 &lt;url-pattern&gt;/&lt;/url-pattern&gt;로 변경하는 거 이외에는 모두 같습니다. web.xml &lt;servlet-mapping&gt; &lt;servlet-name&gt;dispatcher&lt;/servlet-name&gt; &lt;url-pattern&gt;*.form&lt;/url-pattern&gt; &lt;!--\"*.form\"을 \"/\"로 변경--&gt;&lt;/servlet-mapping&gt; 5. index.jsp 작성Hello Spring Store! 라는 문구를 출력해보겠습니다. index.jsp &lt;%@ page contentType=\"text/html;charset=UTF-8\" language=\"java\" %&gt;&lt;html&gt;&lt;head&gt; &lt;title&gt;Spring Store&lt;/title&gt;&lt;/head&gt;&lt;body&gt;Hello Spring Store!&lt;/body&gt;&lt;/html&gt; 6. Tomcat 설정우측 상단의 [Add Configuration…] 클릭 좌측 상단의 [+] - [Tomcat Server] - [Local] 선택 [Server] 탭의 [Application server]에서 [Configure…]를 클릭하여 Tomcat Path 설정 하단의 [Fix] 버튼, 혹은 [Deployment] 탭에서 Deploy될 서버 선택 실행, 성공 References [SpringMVC] IntelliJ에서 SpringMVC, Gradle 설정 - Heee’s Development Blog [intellij] spring mvc + gradle 프로젝트 생성 - SofL Start SpringMVC project in IntelliJ - Jihun’s Development Blog","categories":[{"name":"Study","slug":"study","permalink":"https://delf-lee.github.io/categories/study/"}],"tags":[{"name":"InterllJ","slug":"interllj","permalink":"https://delf-lee.github.io/tags/interllj/"},{"name":"Spring","slug":"spring","permalink":"https://delf-lee.github.io/tags/spring/"},{"name":"SpringMVC","slug":"springmvc","permalink":"https://delf-lee.github.io/tags/springmvc/"},{"name":"Gradle","slug":"gradle","permalink":"https://delf-lee.github.io/tags/gradle/"},{"name":"Tomcat","slug":"tomcat","permalink":"https://delf-lee.github.io/tags/tomcat/"}]},{"title":"Facebook에서 OAuth 구현해보기","slug":"post/oauth-sample-facebook","date":"2018-11-01T08:12:01.000Z","updated":"2018-11-11T07:38:06.994Z","comments":true,"path":"post/oauth-sample-facebook/","link":"","permalink":"https://delf-lee.github.io/post/oauth-sample-facebook/","excerpt":"","text":"간단하게 Oauth를 사용해보는 것을 목적으로 한 포스팅입니다. 용어 Resource Owner: 사용자 Resource Server: 사용자의 정보를 가지고 있는 서비스(google, facebook 등) Client: 내가 개발한 어플리케이션 및 서비스 목표facebook으로 로그인하기를 이용하여 내 계정에 대한 정보 받아보기(= facebook에서 사용자의 access token 발급 받기) 진행 과정 페이스북 앱 생성 및 설정 테스트를 위한 웹 서버 올리기 ‘facebook 로그인하기’를 제공할 페이지 작성 사용자(나)에게 권한 요청 후 승인 facebook에서 내 정보 요청해서 출력하기 참고https://github.com/Delf-Lee/OAuth-tutorial 1. 페이스북 앱 생성 및 설정 facebook에 앱을 생성합니다. Client ID, Client Secret을 발급 받습니다.(facebook에서는 앱 ID, 앱 시크릿 코드) Redirection URI를 설정합니다. 절차 Facebook for developer 가입 및 로그인 [내 앱] - [새 앱 만들기] 표시 이름, 이메일 기입 [앱 만들기] [제품 추가] - [Facebook 로그인] - 설정 [웹] 선택 서비스 제공할 URL 입력 - [Save] 여기서는 https://localhost:8000/ 을 입력하였습니다. [facebook 로그인] - [설정] - 유효한 OAuth 리디렉션 URI Redirection URI 입력 https://localhost:8000/OAuth-tutorial (이 예제에서 사용할 주소입니다) Redirection URI는 Client에서 facebook 로그인 기능을 제공할 페이지의 URI입니다. 2. 웹 서버 올리기어떤 웹 서버든 상관 없지만, 이 과정에서는 간단하게 nodejs에서 제공하는 loacl-web-server를 사용하겠습니다. npm: local-web-server 설치: npm install -g local-web-server 실행: ws --https - https 3. facebook 로그인하기를 제공할 페이지 작성 방법 1. URL을 이용한 직접 요청 방법 2. Javascript SDK를 이용한 요쳥방법 1. URL을 이용한 직접 요청 목표 ‘권한승인 바로가기’를 누르면 facebook 권한설정 페이지으로 이동 승인 완료 후, facebook에서 내 정보를 가져와서 이름 출력 개발자 도구로 응답 메시지 확인&lt;!doctype html&gt;&lt;html&gt;&lt;body&gt; &lt;div id=\"notice\"&gt; 이 기능을 이용하기 위해서는 facebook에서 권한을 승인해야 합니다. &lt;!-- Resouce Owner가 Resouce Server에게 요청할 URL--&gt; &lt;a href=\"https://www.facebook.com/v3.2/dialog/oauth? client_id=&#123;app-id&#125; &amp;redirect_uri=&#123;redirect-uri&#125; &amp;state=&#123;state-param&#125; &amp;scope=email\"&gt; 권한승인 바로가기&lt;/a&gt; &lt;/div&gt; &lt;div id=\"welcome\" style=\"display:none\"&gt;&lt;/div&gt; &lt;!-- 송수신 확인을 위한 스크립트 --&gt; &lt;script&gt; var atr = location.href.match('access_token=([^&amp;]*)'); // 문자열 파싱 console.log('access token regular expression : ', atr); if (atr) &#123; var access_token = atr[1]; // 토큰 추출 console.log('access token : ', access_token); fetch( \"https://graph.facebook.com/v3.2\" + \"/me\" + \"/?access_token=\" + access_token + \"&amp;fields=name, email\" // 이름과 이메일 요청 ) .then(function (raw) &#123; return raw.json(); &#125;) .then(function (result) &#123; if (result.error) &#123; &#125; else &#123; console.log(result); document.querySelector('#notice').style.display = 'none'; document.querySelector('#welcome').style.display = 'block'; document.querySelector('#welcome').innerHTML = \"Welcome, \" + result.name; &#125; &#125;) &#125; &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 리디렉션 할 URL과 필수 매개변수 참고: facebook-로그인 플로 직접 빌드 https://www.facebook.com/v3.2/dialog/oauth? client_id=&#123;app-id&#125; &amp;redirect_uri=&#123;redirect-uri&#125; &amp;state=&#123;state-param&#125; app-id앱의 대시보드에 있는 앱 ID입니다. redirect_uri사용자가 다시 로그인하도록 리디렉션할 URL입니다. facebook 앱에서 등록된 유효한 OAuth 리디렉션 URI이어야 합니다. 지금은 현재 페이지로 설정해줍니다. (ex&gt; https://localhost:8000/OAuth-tutorial) state:요청과 콜백 간에 상태를 관리하기 위해 앱에서 생성하는 문자열 값입니다. 이 매개변수는 사이트 간 요청 위조를 차단하는 데 사용되어야 하며, 리디렉션 URI에서 변경되지 않은 상태로 개발자에게 다시 전달됩니다. 매개변수 scope필수는 아니지만, Client가 Resource Server에서 접근수 있는 Resource owner의 정보의 범위를 표기합니다. 예제에선 1234라는 임시 값을 넣어주었습니다. URL에 ...&amp;scope={scope_name}추가 scope의 종류 참고: 권한 참조 - Facebook 로그인 결과 권한 바로가기를 누릅니다. 이미 권한이 있다면, 로그인 화면은 나타나지 않습니다. 권한 승인 후 URL이 변경된 것을 확인할 수 있습니다. 이렇게 전달 받은 값(access token)으로 사용자의 정보에 접근할 때 이용할 수 있습니다. https://localhost:8000/oauth-test/fb-low.html#state=1234++++++++&amp;access_token=EAADlUGrSbD4BALDg1675ypt9ZAbCI8axbVv1d3H0Du963ntL5q7AkRwrrR3GWhOAZB2NsUZAdUq5JPUZAP08Tmu8yjTvnB3bTYOvwwIJjYzO4xU7Sd71a2mSxlqR2TZBxCsfGJJZCzcftK8htv6edsO5mXOKhYcZCDYIwZC8sy2sLRtZAqMZAgZBJoxn1p2ZA7HMZB74ZD&amp;expires_in=7168&amp;reauthorize_required_in=7776000&amp;data_access_expiration_time=1549695632 방법 2. Javascript SDK를 이용한 요쳥참고 결과 로그인이 안되었다면 로그인 버튼 띄우기 로그인이 되었지만, 권한 승인이 안되있으면 facebook 권한설정 페이지로 이동 로그인이 되었고, 권한 승인도 되어있으면 이름과 로그아웃 버튼 띄우기 구현 FB.getLoginStatus()를 통해 로그인 여부를 확인합니다. response 값에 access token값이 포함되어 있습니다. 로그인 여부에 따라 FB.login()를 이용하여 로그인을 유도합니다.&lt;!doctype html&gt;&lt;html&gt;&lt;body&gt; &lt;div id=\"welcome\"&gt;&lt;/div&gt; &lt;div id=\"notice\"&gt; &lt;input type=\"button\" id=\"authBtn\" value=\"checking...\" onclick=\" if(this.value === 'Login')&#123; FB.login(function(response)&#123; refreshAuthStatus(); &#125;, &#123;scope:'email'&#125;); // scope 설정 가능 &#125; else &#123; FB.logout(function(response)&#123; refreshAuthStatus(); &#125;); &#125; \"&gt; &lt;/div&gt; &lt;script&gt; function refreshAuthStatus() &#123; FB.getLoginStatus(function (response) &#123; console.log('FB.getLoginStatus', response); if (response.status === 'connected') &#123; FB.api('/me', function (response) &#123; // me, 혹은 사용자 id 입력 document.querySelector('#authBtn').value = 'Logout'; document.querySelector('#welcome').innerHTML = 'Welcome, ' + response.name; &#125;) &#125; else &#123; document.querySelector('#authBtn').value = 'Login'; document.querySelector('#welcome').innerHTML = ''; &#125; &#125;); &#125; window.fbAsyncInit = function () &#123; FB.init(&#123; appId: '&#123;app-id&#125;', // app-id 입력하기 autoLogAppEvents: true, xfbml: true, version: 'v3.2' &#125;); console.log('Init'); refreshAuthStatus(); &#125;; (function (d, s, id) &#123; var js, fjs = d.getElementsByTagName(s)[0]; if (d.getElementById(id)) &#123; return; &#125; js = d.createElement(s); js.id = id; // js.src = \"https://connect.facebook.net/ko_KR/sdk.js\"; js.src = \"https://connect.facebook.net/en_US/sdk.js\"; fjs.parentNode.insertBefore(js, fjs); &#125;(document, 'script', 'facebook-jssdk')); &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 결과 로그인하기 전 authResponse의 status값이 not_authorized인 것을 확인할 수 있습니다. 마찬가지로 권한 승인이 되어 있다면 이 화면은 나타나지 않습니다. 방법 1에서 URL로 받았던 access token값이 이번엔 authResponse에 포함되어 있는 것을 확인할 수 있습니다. 기타facebook에서 권한 해제를 하고싶다면, [설정] - [앱 및 웹 사이트]에서 해당하는 앱을 삭제합니다.","categories":[{"name":"Study","slug":"study","permalink":"https://delf-lee.github.io/categories/study/"}],"tags":[{"name":"Web","slug":"web","permalink":"https://delf-lee.github.io/tags/web/"},{"name":"Oauth","slug":"oauth","permalink":"https://delf-lee.github.io/tags/oauth/"}]},{"title":"String vs StringBuilder vs StringBuffer","slug":"post/string-stringbuilder-stringbuffer","date":"2018-10-29T17:00:25.000Z","updated":"2018-11-02T19:37:20.550Z","comments":true,"path":"post/string-stringbuilder-stringbuffer/","link":"","permalink":"https://delf-lee.github.io/post/string-stringbuilder-stringbuffer/","excerpt":"","text":"세 클래스의 공통점은 모두 문자열(String)을 저장하고 관리하는 클래스라는 것입니다. StringString클래스는 immutable(불변)하다는 특성이 있습니다. String클래스의 문자열을 저장하는 char[]을 보면 final로 선언되어 있다는 것을 확인할 수 있습니다.public final class String implements java.io.Serializable, Comparable&lt;String&gt;, CharSequence &#123; /** The value is used for character storage. */ private final char value[]; ...&#125; 그 때문에, 한번 할당한 문자열을 변경하는 것은 불가능하며, 더하기 연산을 하여 붙일 시 새로운 객체가 생성되어 재할당 됩니다. String s = \"hello\";System.out.println(s.hashCode()); // 99162322s += \" delf!\";System.out.println(s.hashCode()); // 1776255224 반복적으로 문자열을 이어 붙이면 Heap 영역에 참조를 잃은 문자열 객체가 계속해서 쌓이게 됩니다. 물론 나중에 GC에 의해 수거가 되지만, 메모리 관리 측면에서 이러한 코드는 결코 좋다고 할 수 없습니다. 또한 계속해서 객체를 생성하기 때문에 연산 속도적인 측면에서도 뒤떨어집니다. 이러한 String의 성능 이슈를 개선하기 위해 JDK 1.5 이상에서는 컴파일 단계에서 내부적으로 StringBuilder로 변경되어 동작됩니다. StringBuilder반면 StringBuilder클래스는 mutable(가변) 합니다. 상속 받고있는 AbstractStringBuilder 클래스의 내부를 보면 변경 가능하도록 선언되어 있습니다.abstract class AbstractStringBuilder implements Appendable, CharSequence &#123; /** * The value is used for character storage. */ char[] value; ...&#125; append() 메소드를 호출하면, char[] 배열의 길이를 늘리고 같은 객체에 문자열을 더합니다. 아래의 코드를 보면 append() 호출 이후에도 StringBuilder 객체에 변함이 없음을 확인할 수 있습니다.StringBuilder s = new StringBuilder(\"hello\");System.out.println(s.hashCode()); // 859417998s.append(\" delf!\");System.out.println(s.hashCode()); // 859417998 String vs StringBuilder위에서도 언급했듯이, String의 성능 이슈를 개선하기 위해 JDK 1.5 이상에서는 컴파일 단계에서 내부적으로 StringBuilder로 변경되어 동작됩니다. 예를들어 아래와 같이 + 연산자를 이용한 코드는String outside = str1 + str2 ... + strN; 내부적으로 다음과 같이 동작하게 됩니다.String inside = new StringBuilder(String.valueOf(str1)).append(str2).[...].apend(strN).toString(); +연산과 append()메소드의 실질적인 성능 차이는 거의 없습니다만, 아래와 같은 코드는 매 루프마다 StringBuilder객체가 생성되므로 기존(JDK 1.5 이하)의 String의 +연산과 같이 마찬가지로 불필요한 객체가 쌓이게 되고 성능에 악영향을 미칩니다.for (int i = 0; i &lt; 100000; i++) &#123; string += value;&#125; 때문에 어떠한 경우라도 반복문에서는 String의 + 연산은 피하는게 좋습니다. 반복문에서의 String과 StringBuilder의 속도차이 실험 결과 약 만배의 속도 차이를 확인할 수 있었습니다. - code StringBufferStringBuffer는 synchronized가 적용되어 멀티스레드 환경에서 Thread-safe하게 동작할 수 있습니다. 한마디로 동기화를 지원하는 StringBuilder라고 이해하시면 편합니다.// StringBuffer 클래스의 append 메소드@Overridepublic synchronized StringBuffer append(CharSequence s) &#123; toStringCache = null; super.append(s); return this;&#125; StringBuilder vs StringBuffer하나의 StringBuilder객체와 StringBuffer객체에 10,000개의 스레드가 접근해서 append()를 수행히는 실험을 해봤습니다.public class AppendTest &#123; private static StringBuilder builder = new StringBuilder(\"\"); private static StringBuffer buffer = new StringBuffer(\"\"); public static void main(String[] args) throws InterruptedException &#123; /* 1. StringBuilder에 문자열 붙이는 스레드 10000개 생성 */ Appenders[] appenders = new Appenders[10]; for (int i = 0; i &lt; appenders.length; i++) &#123; appenders[i] = new Appenders(builder,10000, \"a\"); &#125; for (Appenders a : appenders) &#123; // 스레드 시작 a.start(); //10000개의 스레드가 하나의 StringBuilder에 append &#125; Thread.sleep(3000); // 3초 대기 System.out.println(builder.length()); /* 2. StringBuffer에 문자열 붙이는 스레드 10000개 생성 */ appenders = new Appenders[10]; for (int i = 0; i &lt; appenders.length; i++) &#123; // 스레드 10000개 생성 appenders[i] = new Appenders(buffer,10000, \"a\"); &#125; for (Appenders a : appenders) &#123; // 스레드 시작 a.start(); // 10000개의 스레드가 하나의 StringBuffer에 append &#125; Thread.sleep(3000); // 3초 대기 System.out.println(buffer.length()); &#125;&#125;class Appenders extends Thread &#123; private Appendable ap; private int cnt; private String s; public Appenders(Appendable ap, int cnt, String s) &#123; this.cnt = cnt; this.ap = ap; this.s = s; &#125; @Override public void run() &#123; while (cnt-- &gt; 0) &#123; try &#123; ap.append(s); &#125; catch (IOException e) &#123;&#125; &#125; &#125;&#125; 실행 결과93221 // 매 실행 마다 결과가 다름.100000 Thread-safe하지 않은 StringBuilder에 여러 스레드가 동시에 append()할 경우에, 기존 문자열 뒤 인덱스 값이 동기화되지 않아 중복된 장소에 여러 번 값을 덮어 쓰는 경우가 발생하고, 목표 횟수만큼 문자열이 추가되지 않게됩니다. 심지어 char[]의 버퍼를 늘리기 전에 문자 할당을 시도해서 ArrayIndexOutOfBoundsException이 발생하기도 하지요. 반면, synchronized 키워드를 지원하는 StringBuffer는 깔끔하게 목표 횟수만큼 문자열이 추가되었습니다. 정리String 단순히 문자열을 참조하거나 탐색 및 검색이 잦을 때 좋습니다. StringBuilder 런타임 때, 반복적인 문자열 추가 연산이 많을 때 좋습니다. 단일 스레드 환경이라면 StringBuffer보다 성능이 좋을 수 있습니다. StringBuffer 멀티 스레드 환경에서 반복적인 추가 문자 추가 연산이 많을 때 좋습니다. Reference http://jeong-pro.tistory.com/85 https://www.slipp.net/questions/271 http://hackersstudy.tistory.com/12 https://medium.com/@joongwon/string-%EC%9D%98-%EB%A9%94%EB%AA%A8%EB%A6%AC%EC%97%90-%EB%8C%80%ED%95%9C-%EA%B3%A0%EC%B0%B0-57af94cbb6bc","categories":[{"name":"Study","slug":"study","permalink":"https://delf-lee.github.io/categories/study/"}],"tags":[{"name":"Java","slug":"java","permalink":"https://delf-lee.github.io/tags/java/"}]},{"title":"RAID","slug":"post/raid","date":"2018-10-11T03:41:01.000Z","updated":"2018-10-19T16:20:17.862Z","comments":true,"path":"post/raid/","link":"","permalink":"https://delf-lee.github.io/post/raid/","excerpt":"","text":"RAID란 Redundant Array of Inexpensive Disks 또는 Redundant Array of Independent Disks의 약자로 여러개의 하드디스크를 하나의 논리적 가상 디스크로 구성하여 대용량 저장장치로 사용할 수 있는 기법입니다. RAID 시스템은 동일한 데이터를 여러 개의 디스크에 중복 저장하면서도, 운영체계에는 하나의 단일 디스크로 인식시킴으로써, 내고장성의 증가와 데이터 접근 효율성을 높여주는 장점이 있습니다. RAID 계층 - RAID Level데이터를 나누는 다양한 방법이 존재하며, 이 방법들을 레벨이라 하는데, 레벨에 따라 저장장치의 신뢰성을 높이거나 전체적인 성능을 향상시키는 등의 다양한 목적을 만족시킬 수 있습니다. 최초에 제안되었을 때는 다섯가지의 레벨이 존재했는데, 이후에 중첩 레벨을 비롯한 여러 가지 다른 레벨들이 추가되었습니다. RAID 0 - 스트라이핑RAID의 가장 기본적인 구현방식으로 Striping(스트라이핑)이라고 하며, 하나의 데이터를 여러 디스크에 분산하여 저장합니다. 2개 이상의 디스크가 필요하며, 디스크가 연결되는 만큼 용량이 증가합니다. 장점입출력 속도가 빠릅니다. 여러 개의 디스크에 분산하여 저장하고 각 디스크 마다 입출력을 병렬적으로 처리하기 때문에, 기본적으로 N개의 디스크를 사용한다면, 이론상 N배 빠릅니다. 단점Striping(스트라이핑) 되어 있는 하드디스크 중 1개만 장애를 일으키더라도 데이터를 모두 유실할 위험성이 있습니다. 디스크의 수가 증가할 수록 위험은 더욱 증가합니다. RAID 1 - 미러링하나의 하드디스크에 기록되는 모든 데이터가 나머지 하나의 하드디스크에 똑같이 복사됩니다. 때문에 Mirroring(미러링)이라고도 하며 이 경우 2개의 하드디스크 중 1개가 장애를 일으키더라도 남은 1개의 데이터는 장애를 일으키지 않은 하드디스크의 데이터와 똑같기 때문에 안정성 측면에서 상당히 우수한 구성입니다. 장점드라이브 하나가 고장 나면 똑같은 내용의 다른 드라이브가 하나 더 있기 때문에 매우 안전합니다. RAID 1은 읽기 성능이 단일 드라이브에서의 성능과 같거나 훨씬 좋습니다. 단점각 드라이브는 미러링되기 때문에 전체 용량의 절반밖에 사용하지 못합니다. 드라이브 두 개에 동일한 데이터를 써야 하기 때문에 쓰기 성능이 나쁩니다. 하지만 다른 RAID 레벨의 쓰기 성능보다는 낫습니다. RAID 3데이터는 바이트 단위로 쪼개져서 모든 디스크에 균등하게 나뉘어 저장되고 패리티 정보는 별도의 전용 디스크에 저장됩니다. 패리티Data의 오류검출 확인에 사용되는 개념. 정보 블록과 연결된 중복 정보. 패리티는 오류 후 데이터를 재구축하는 데 사용되는 계산된 값입니다. 장점한 개의 드라이브가 고장 나는 것을 허용하며 순차적 쓰기(sequential write) 성능과 순차적 읽기(sequential read) 성능이 우수합니다. 단점RAID 3은 보통 효율적이지만 임의 쓰기(random write) 성능이 나쁘고 임의 읽기(random read) 성능은 준수합니다. 또한 패리티 정보가 저장되어 있는 하드디스크에 장애가 발생하면 복구가 불가능하다는 단점이 있습니다. 또한 패리티 하드디스크에 병목현상이 생겨 속도가 저하될 수 도 있습니다. RAID 4모든 파일은 블럭으로 쪼개지고 각 블럭은 여러 디스크에 저장되지만 균등하진 않습니다. RAID 3처럼 패리티를 처리하기 위해 별도의 디스크를 사용합니다. 동시 트랜잭션 사용량이 많은 시스템에서 읽기 속도는 매우 중요한데 이런 시스템에 적합합니다. 장점드라이브 하나가 고장 나는 것을 허용하고 읽기 성능이 매우 좋습니다. 단점쓰기 성능이 나쁘지만 블럭 읽기(block read) 성능은 괜찮습니다. RAID 3와 마찬가지로 패리티 디스크 장애에 대한 문제가 있습니다. RAID 3와 RAID 4의 차이RAID 3은 Byte단위로 데이터를 저장하는 반면 RAID 4는 Block단위로 저장합니다.Block단위로 저장을 할 경우 작은 파일의 경우는 한번의 작업으로 데이터를 읽을 수 있기 때문에 성능상의 장점이 있습니다. 레벨 3은 동기화를 거쳐야 하기 때문에 3보다는 레벨 4를 많이 사용합니다. RAID 5RAID 3과 RAID 4의 단점을 보완한 방식으로, 패리티 정보의 저장을 전담하는 하드디스크 대신 모든 하드디스크에 패리티 정보를 분산 저장합니다. 장점지원하는 회사가 많고 한 개의 드라이브가 고장 나는 것을 허용합니다. RAID 3과 RAID 4의 단점을 해결한 형태이며 고급 RAID Controller에서 현재 많이 쓰이고 있는 형태입니다. 이는 별도의 오류정정부호(ECC) 드라이브를 두지 않고, 각 드라이브에 분산되어 ECC 드라이브에 대한 병목현상을 막아주며 ECC를 위한 알고리즘 때문에 성능 면에서는 여전히 RAID 0 보다 떨어지지만 성능, 안정성, 용량의 세 부분을 고려한 형태입니다. 단점디스크 재구성(rebuild)이 매우 느리고 방식은 쓰기(Write)에는 패리티 정보가 분산되어 저장되기 때문에 병목을 줄여주지만, 읽기(Read)에서는 사방에 흩어져 있는 패리티 정보를 갱신하며 읽게 되기 때문에 성능 저하가 생길 수밖에 없습니다. RAID 6RAID 5와 비슷하지만, 다른 드라이브들 간에 분포되어 있는 2차 패리티 구성을 포함함으로써 매우 높은 장애대비 능력을 제공합니다. 장점두 개의 드라이브까지 고장 나는 것을 허용하고,하드를 스트라이핑으로 묶었기 때문에 RAID 0+1이나 RAID 10보다 성능은 더 높고 신뢰성도 우수 합니다. 단점패리티 정보를 2중으로 저장하면서 읽기 성능은 RAID 5와 비슷하지만 쓰기 작업 구현이 아주 복잡해서 일반적으로 잘 사용하지 않습니다. RAID 0+1RAID 0으로 먼저 묶고, 그 다음 RAID 1로 묶는 방법입니다. 디스크 N개를 A개씩 RAID 0로 묶고, 이렇게 스트라이핑 된 볼륨 N/A개를 RAID 1로 미러링합니다. 장점RAID 0의 속도와 RAID 1의 안정성이라는 각 장점을 합쳤습니다. RAID 10에 비해 기술적으로 단순합니다. 단점RAID 10에 비해 확률적으로 안정성이 떨어집니다. 복구 시간이 오래 걸립니다. RAID 10RAID 1으로 먼저 묶고, 그 다음 RAID 0으로 묶는 방법입니다. 디스크 N개를 A개씩 RAID 1로 묶고, 이렇게 미러링 된 볼륨 N/A개를 RAID 0으로 스트라이핑 합니다. 장점RAID 0의 속도와 RAID 1의 안정성이라는 각 장점을 합쳤습니다. RAID 0+1에 비해 디스크 장애 발생시 복구가 수월합니다. 단점기술적으로 복잡합니다. RADE 10과 RAID 0+1의 차이 안정성 RAID 10의 경우에는 HDD1이 나면 HDD 1, 2까지만 사용이 불가능합니다. 하지만 RAID 0+1의 경우에는 HDD 1, 2, 3이 사용할 수 없게 됩니다. 복구에 걸리는 시간 RAID 0+1의 경우에는 만약 HDD1이 고장 났을 때, HDD 4, 5, 6의 내용을 HDD 1,2,3에 통째로 붙여 넣어야 하기 때문에 REBUILD 시간이 오래 걸립니다. 하지만 RAID 10의 경우에는 HDD1이 고장나도 HDD2의 내용만 붙여넣으면 되기 때문에 REBUILD 시간이 RAID 0+1에 비해 덜 걸립니다. Reference http://myung.co.kr/home/content/view.do;jsessionid=A6B15A9DDBAFC69F6A4086A892DDB1E9?contentKey=372&amp;sTxt=&amp;cngKey=&amp;searchTxt=&amp;menuKey=896 http://blog.naver.com/PostView.nhn?blogId=jjanggu327&amp;logNo=80120877848&amp;parentCategoryNo=&amp;categoryNo=238&amp;viewDate=&amp;isShowPopularPosts=false&amp;from=postView https://m.blog.naver.com/PostView.nhn?blogId=limoremo&amp;logNo=220059411083&amp;proxyReferer=https%3A%2F%2Fwww.google.co.kr%2F","categories":[{"name":"Study","slug":"study","permalink":"https://delf-lee.github.io/categories/study/"}],"tags":[{"name":"OS","slug":"os","permalink":"https://delf-lee.github.io/tags/os/"}]},{"title":"RESTful과 REST API","slug":"post/restful","date":"2018-10-08T18:46:41.000Z","updated":"2018-10-19T16:20:17.862Z","comments":true,"path":"post/restful/","link":"","permalink":"https://delf-lee.github.io/post/restful/","excerpt":"","text":"말하고 싶은 것 REST란 무엇인가? RESTful하다는 것은 무엇을 의미하며, 어떻게 해야하는가? REST REST는 REpresentation State Transfer의 약자로, WWW(World Wide Web) 같은 분산 하이퍼미디어 시스템에서 운영되는 소프트웨어 아키텍처 스타일입니다. 로이 필딩(Roy Fielding)은 HTTP의 주요 저자 중 한 사람으로 그 당시 웹(HTTP) 설계의 우수성에 비해 제대로 사용되어지지 못하는 모습에 안타까했고, 2000년에 그의 박사학위 논문에서 웹의 장점을 최대한 활용할 수 있는 아키텍처로써 REST를 발표했습니다. REST는 HTTP/1.1 스펙과 동시에 만들어졌는데, HTTP 프로토콜을 정확히 의도에 맞게 활용하여 디자인하게 유도하고 있기 때문에 디자인 기준이 명확해지며, 의미적인 범용성을 지니므로 중간 계층의 컴포넌트들이 서비스를 최적화하는 데 도움이 됩니다. REST의 기본 원칙을 성실히 지킨 서비스 디자인은 “RESTful 하다” 라고 흔히 표현합니다. REST의 6가지 원칙(제약 사항)1. Uniform InterfaceUniform Interface는 URI로 지정한 리소스에 대한 조작을 통일되고 한정적인 인터페이스로 수행하는 아키텍처 스타일을 말합니다. REST의 또 다른 큰 특징 중 하나는 REST API 메시지만 보고도 이를 쉽게 이해 할 수 있는 자체 표현 구조(Self-descriptiveness)로 되어 있다는 것입니다. 2. StatelessREST는 무상태성 성격을 갖습니다. 다시 말해 작업을 위한 상태정보를 따로 저장하고 관리하지 않습니다. 세션 정보나 쿠키정보를 별도로 저장하고 관리하지 않기 때문에 API 서버는 들어오는 요청만을 단순히 처리하면 됩니다. 때문에 서비스의 자유도가 높아지고 서버에서 불필요한 정보를 관리하지 않음으로써 구현이 단순해집니다. 3. CacheableREST의 가장 큰 특징 중 하나는 HTTP라는 기존 웹표준을 그대로 사용하기 때문에, 웹에서 사용하는 기존 인프라를 그대로 활용이 가능합니다. 따라서 HTTP가 가진 캐싱 기능이 적용 가능합니다. HTTP 프로토콜 표준에서 사용하는 Last-Modified태그나 E-Tag를 이용하면 캐싱 구현이 가능합니다. 4. Client - Server 구조REST 서버는 API 제공, 클라이언트는 사용자 인증이나 컨텍스트(세션, 로그인 정보)등을 직접 관리하는 구조로 각각의 역할이 확실히 구분되기 때문에 클라이언트와 서버에서 개발해야 할 내용이 명확해지고 서로간 의존성이 줄어들게 됩니다. 5. Hierarchical System(Layered System)REST 서버는 다중 계층으로 구성될 수 있으며 보안, 로드 밸런싱, 암호화 계층을 추가해 구조상의 유연성을 둘 수 있고 PROXY, 게이트웨이 같은 네트워크 기반의 중간매체를 사용할 수 있게 합니다. 6. Code-on-Demend(optional)서버가 네트워크를 통해 클라이언트에 프로그램을 전달하면 그 프로그램이 클라이언트에서 실행될 수 있어야합니다. (Java applet이나 Javascript 같은 것을 말함) 다만 이 제약조건은 필수는 아닙니다. REST API위 REST의 원칙에 따라 디자인한 API를 REST API라고 합니다. REST API의 구성REST API는 자원(Resource), 행위(Verb), 표현(Representations)의 3가지 요소로 구성됩니다. REST는 자체 표현 구조(Self-descriptiveness)로 구성되어 REST API만으로 요청을 이해할 수 있습니다. 구성 요소 내용 표현방법 Resouce 자원 HTTP URI Verb 자원에 대한 행위 HTTP method Representations 자원에 대한 행위의 내용 HTTP Message Pay Load REST API 설계 시, 주의할 점자원에 대한 행위는 HTTP Method으로 표현한다.URI는 정보의 자원을 표현해야 해야합니다. 또한 그 자원에 대한 행위는 HTTP Method(GET, PUT, POST, DELETE)로 표현합니다. 대부분의 행위는 HTTP Method만으로 표현이 가능하기 때문에, URI에 CRUD를 사용하지 않도록 합니다. 예를들어 임의의 회원(사용자)에 대한 정보를 삭제하는 API를 작성할 때, DELETE /members/delete/1 위와 같은 방식은 REST를 제대로 적용하지 않은 URI입니다. URI는 자원을 표현하는데 중점을 두어야 합니다. delete와 같은 행위에 대한 표현이 들어가서는 안됩니다. 위에서 설명한 두 가지를 적용한다면, 다음과 같이 수정할 수 있습니다.DELETE /members/1 그 이외에는, 회원정보 조회 GET /members/show/1 (Not RESTful)GET /members/1 (RESTful) 회원 추가 POST /members/insert/2 (NOT RESTful)POST /members/2 (RESTful) 위와 같이 작성할 수 있습니다. HTTP Method자원은 크게 Collection과 Element로 나누어 표현할 수 있으며, 아래 테이블에 기초한다면 서버 대부분과의 통신 행태를 표현할 수 있습니다. Collection URI, ex) /memeber/ Element URI, ex) /member/:id GET 컬렉션에 속한 자원들의 URI나 그 상세사항의 목록을 보여준다. 요청한 컬렉션 내 자원을 반환한다. PUT 전체 컬렉션은 다른 컬렉션으로 교체한다. 해당 자원을 수정한다. POST 해당 컬렉션에 속하는 새로운 자원을 생성한다.자원의 URI는 시스템에 의해 할당된다. 해당 자원에 귀속되는 새로운 자원을 생성한다. DELETE 전체 컬렉션을 삭제한다. 해당 컬렉션내 자원을 삭제한다. Collection과 DocumentResouce는 Collection과 Document로 구분할 수 있습니다. Document는 Element라고도 표현하며, 하나의 Resouce 개체, 또는 문서를 말합니다. 그러한 Document의 집합을 Collection이라고 할 수 있습니다. 예를들어,http://delf.com/sport/soccer 다음 URI는 sports라는 Collection과 soccer라는 Document로 표현되고 있습니다. sports Collection에는 soccer이외에 baseball이나 basketball등이 포함될 수 있습니다. 좀 더 예를 들어보자면,http://delf.com/sports/soccer/players/13 sports, players 컬렉션과 soccer, 13(13번인 선수)를 의미하는 도큐먼트로 URI가 이루어지게 됩니다. 여기서 중요한 점은 컬렉션은 복수로 사용하고 있다는 점입니다. 좀 더 직관적인 REST API를 위해서는 컬렉션과 도큐먼트를 사용할 때 단수 복수도 지켜준다면 좀 더 이해하기 쉬운 URI를 설계할 수 있습니다. 소문자를 사용한다.대문자를 사용해도 상관이 없지만, 대문자와 소문자가 구분된다는 사실은 알고있어야 합니다. 다음 URI는 모두 다른 리소스 입니다.http://delf.com/RESTfulAPIhttp://delf.com/RESTfulapihttp://delf.com/restfulAPI 공백과 언더바(_)보다는 하이픈(-)을 사용한다.언더바(_)를 사용하면 밑줄에 겹쳐서 보이지 않게 되거나 공백을 사용하면 %20과 같이 인코딩되어 가독성이 떨어지게 됩니다. 사용이 불가능한 것은 아니지만 되도록 하이픈(-) 사용을 권장합니다.http://delf.com/what-is-rest-api 자원에 대한 확장자를 명시하지 않는다.URI에 확장자를 표시하기 보다는 Accept header를 이용합니다. http://delf.com/cat.txt 위의 URI를 REST API로 구현한다면 다음과 같아집니다.GET /cat HTTP/1.1Host: delf.comAccept: text/plain 또는, 다음같이 다른 형대로 요청할 수 있습니다.GET /cat HTTP/1.1 Host: delf.comAccept: text/csv 이로써, 하나의 Resource에 대해서 하나의 URI에 대응할 수 있게되고, 클라이언트의 요청에 대한 응답을 좀더 유연하게 할 수 있습니다. Reference https://spoqa.github.io/2012/02/27/rest-introduction.html https://meetup.toast.com/posts/92 http://amazingguni.github.io/blog/2016/03/REST에-대한-이해-1 http://blog.remotty.com/blog/2014/01/28/lets-study-rest/ 도움이 될만한 글 https://blog.npcode.com/2017/04/03/rest의-representation이란-무엇인가/ https://spoqa.github.io/2013/06/11/more-restful-interface.html","categories":[{"name":"Study","slug":"study","permalink":"https://delf-lee.github.io/categories/study/"}],"tags":[{"name":"Web","slug":"web","permalink":"https://delf-lee.github.io/tags/web/"},{"name":"HTTP","slug":"http","permalink":"https://delf-lee.github.io/tags/http/"}]},{"title":"Databese Connection Pool","slug":"post/connection-pool","date":"2018-10-04T03:04:44.000Z","updated":"2018-10-19T16:20:17.862Z","comments":true,"path":"post/connection-pool/","link":"","permalink":"https://delf-lee.github.io/post/connection-pool/","excerpt":"","text":"Connection Pool클라이언트의 요청에 따라 각 어플리케이션의 스레드에서 데이터베이스에 접근하기 위해서는 Connection 필요합니다. Connection pool은 이런 Connection 여러 개 생성해 두어 저장해 놓은 공간(캐시), 또는 이 공간의 Connection을 필요할 때 꺼내 쓰고 반환하는 기법을 말합니다. Connection Pool 라이브러리Connection pool을 제공하는 라이브러리로는 대표적으로 Apache의 Commons DBCP와 Tomcat-JDBC, BoneCP, HikariCP 등이 있습니다. DB에 접근하는 단계 웹 컨테이너가 실행되면서 DB와 연결된 Connection 객체들을 미리 생성하여 pool에 저장합니다. DB에 요청 시, pool에서 Connection 객체를 가져와 DB에 접근하고 처리가 끝나면 다시 pool에 반환합니다. Connction이 부족하면?모든 요청이 DB에 접근하고 있고 남은 Conncetion이 없다면, 해당 클라이언트는 대기 상태로 전환시키고 Pool에 Connection이 반환되면 대기 상태에 있는 클라이언트에게 순차적으로 제공됩니다. 왜 사용할까? 매 연결마다 Connection 객체를 생성하고 소멸시키는 비용을 줄일 수 있습니다. 미리 생성된 Connection 객체를 사용하기 때문에, DB 접근 시간이 단축됩니다. DB에 접근하는 Connection의 수를 제한하여, 메모리와 DB에 걸리는 부하를 조정할 수 있습니다. Thread Pool비슷한 맥락으로 Thread pool이라는 개념도 있습니다. 이 역시 매 요청마다 요청을 처리할 Thread를 만드는것이 아닌, 미리 생성한 pool 내의 Thread를 소멸시키지 않고 재사용하여 효율적으로 자원을 활용하는 기법입니다. Thread Pool과 Connection poolWAS에서 Thread pool과 Connection pool내의 Thread와 Connection의 수는 직접적으로 메모리와 관련이 있기 때문에, 많이 사용하면 할 수록 메모리를 많이 점유하게 됩니다. 그렇다고 반대로 메모리를 위해 적게 지정한다면, 서버에서는 많은 요청을 처리하지 못하고 대기 할 수 밖에 없습니다. 보통 WAS의 Thread의 수가 Conncetion의 수보다 많은 것이 좋은데, 그 이유는 모든 요청이 DB에 접근하는 작업이 아니기 때문입니다. Reference http://brownbears.tistory.com/289 http://devbox.tistory.com/entry/JSP-커넥션-풀-1 https://d2.naver.com/helloworld/5102792 https://www.holaxprogramming.com/2013/01/10/devops-how-to-manage-dbcp/","categories":[{"name":"Study","slug":"study","permalink":"https://delf-lee.github.io/categories/study/"}],"tags":[{"name":"DB","slug":"db","permalink":"https://delf-lee.github.io/tags/db/"}]},{"title":"제네릭(Generic)이란?","slug":"post/java-generic","date":"2018-09-21T06:13:14.000Z","updated":"2018-10-19T16:20:17.861Z","comments":true,"path":"post/java-generic/","link":"","permalink":"https://delf-lee.github.io/post/java-generic/","excerpt":"","text":"제네릭(Generic)이란? 클래스에서 사용할 타입을 클래스 외부에서 설정하는 것 클래스 내부 데이터 타입을 인스턴스를 생성할 때 확정하는 것 제네릭의 활용제네릭 클래스클래스 생성 시, 내부에서 사용할 필드의 타입을 지정할 수 있습니다. 이를 이용하여 다음과 같이 간단한 List를 구현할 수 있습니다.// SimpleList 정의class SimpleList&lt;E&gt; &#123; private &lt;T&gt; elements; public SimpleList(int size) &#123; (E[]) elements = new Object[size]; &#125; ...&#125; 클래스의 인스턴스를 생성할 때 반드시 타입을 명시해주어야 합니다.// SimpleList 사용SimpleList&lt;String&gt; sList = new SimpleList&lt;&gt;(100);sList.add(\"123\");sList.add(\"456\");System.out.println(sList.get(0) + sList.get(1)); // \"123456\"SimpleList&lt;Integer&gt; iList = new SimpleList&lt;&gt;(100);iList.add(123);iList.add(456);System.out.println(iList.get(0) + iList.get(1)); // 579 제네릭 인터페이스// 제네릭 인터페이스 정의interface GnrInterface&lt;T1, T2&gt; &#123; T1 doSomething(T2 t); T2 doSomething2(T1 t);&#125; 제네릭 인터페이스를 이용하여 클래스를 구현할 때 타입을 명시해 주어야 합니다.// 제네릭 인터페이스 구현class GnrInterfaceImpl implements GnrInterface&lt;String, Integer&gt; &#123; @Override public String doSomething(Integer t) &#123; return t.toString(); &#125; @Override public Integer doSomething2(String t) &#123; return Integer.parseInt(t); &#125;&#125; 제네릭 메서드제네릭 메서드는 매개 변수 타입 또는 반환 타입으로 타입 파라미터를 갖는 메소드를 말합니다.제네릭 메서드 선언 시, 반드시 반환 타입 앞에 사용되는 타입 파라미터를 명시해 주어여 합니다. public &lt;T&gt; int genericMethod(List&lt;T&gt; list);public &lt;T&gt; List&lt;T&gt; genericMethod(int n);public &lt;T&gt; List&lt;T&gt; genericMethod(List&lt;T&gt; list);public &lt;T1, T2&gt; List&lt;T1&gt; genericMethod(List&lt;T2&gt; list); 제네릭의 장점과 사용하는 이유 타입 안정성(type-safe)을 제공한다. 코드를 작성할 때 사용할 데이터 타입을 분명하게 명시해주어 컴파일 시의 타입 체크(compile-time type check) 가 가능하여 에러를 사전에 방지할 수 있습니다. type-safe: Runtime 시 타입 체크로 인하여 예측 불가능한 문제가 발생하지 않음을 보장하는 것 타입 체크와 형변환을 생략할 수 있으므로(컴퍼일러가 해주기 때문에) 코드가 명확하고 간결해 집니다. 타입의 종류만 바꾸면 되는 로직일 경우, 코드 재활용이 가능합니다. 1. 타입의 안정성 제공컴파일러는 제네릭 코드에 강한 타입 체킹을 적용해서, 코드가 타입 안전을 위반하는 경우 오류를 발생시킵니다.런타임 오류는 프로그램의 안정성을 낮출 뿐러더 컴파일 오류에 비해 비교적 발견이 어렵습니다.// 제네릭 미사용List list = new ArrayList&lt;&gt;();list.add(\"hello\");list.add(\" generic\");list.add(100); // *정수 추가 가능String s1 = (String) list.get(0) + (String) list.get(1); // \"hello generic\"String s2 = (String) list.get(0) + (String) list.get(2); // [runtime error!] // 제네릭 사용List&lt;String&gt; list = new ArrayList&lt;&gt;(); // 타입 명시list.add(\"hello\");list.add(\" generic\");list.add(100); // [compile error!] *정수 추가 불가능 2. 코드의 간결화타입 체크가 명확해지며, 해당 인스턴스를 사용할 때 일일히 형변환을 할 필요가 없습니다.// 제네릭 미사용List list = new ArrayList();list.add(\"hello\");list.add(\"generic\");System.out.println((String) list.get(0)); // castingSystem.out.println((String) list.get(1)); // casting // 제네릭 사용List&lt;String&gt; list = new ArrayList&lt;&gt;();list.add(\"hello\");list.add(\"generic\");System.out.println(list.get(0)); // no castSystem.out.println(list.get(1)); // no cast 3. 코드의 재활용제네릭을 사용하는 대표적인 예인 Collection은 타입만 명시해 준다면 같은 클래스를 이용하여 다른 타입을 다루는 인스턴스를 따로 생성할 수 있습니다.List&lt;String&gt; strList = new ArrayList&lt;&gt;();List&lt;Integer&gt; intList = new ArrayList&lt;&gt;(); 하지만 만약 제네릭이 없다면 다음과 같이 각각의 클래스를 따로 구현해 주어야 할것입니다.IntegerList intList = new IntegerList();StringList strList = new StringList(); 그리고 그 클래스들의 내부 동작은 유사할 것이고 코드의 중복도 많을 것이라고 예상할 수 있습니다.class IntegerList &#123; ...&#125;class strList &#123; ...&#125; 타입 명명 관례 E - Element K - Key N - Number T - Type V - Value Reference https://github.com/JaeYeopHan/Interview_Question_for_Beginner/tree/master/Java#generic http://devbox.tistory.com/entry/Java-제네릭 https://medium.com/@ohjongsung/자바-제네렉-기본-1267798ffe8e http://devhong.tistory.com/19 http://dohe2014.tistory.com/entry/Why-Use-Generics","categories":[{"name":"Study","slug":"study","permalink":"https://delf-lee.github.io/categories/study/"}],"tags":[{"name":"Java","slug":"java","permalink":"https://delf-lee.github.io/tags/java/"},{"name":"Interview","slug":"interview","permalink":"https://delf-lee.github.io/tags/interview/"}]},{"title":"Cloud Computing를 사용하는 이유","slug":"post/why-cloud-computing","date":"2018-09-18T05:22:13.000Z","updated":"2018-10-19T16:20:17.862Z","comments":true,"path":"post/why-cloud-computing/","link":"","permalink":"https://delf-lee.github.io/post/why-cloud-computing/","excerpt":"","text":"AWS에서 이야기 해주는 Cloud Computing의 장점에 대한 글입니다. 누가 “클라우드 그거 왜 쓰는거야?”라고 물는다면, 이 글이 대답하는데 도움이 될 수 있겠군요! Cloud Computing의 6가지 이점 초기 선투지 비용 없음 운영 비용 절감 탄력적인 운영 및 확장 속도 및 민첩성 비즈니스에만 집중 가능 글로벌 확장 1) 초기 선투자 비용 없음큰 비용과 시간을 소모하는 데이터센터를 구매하고 운용할 필요가 없습니다. 클릭 몇 번으로 수 분 내에 원하는 성능의 서버를 구축할 수 있습니다. On-premis: Cloud와 상반되는 개념으로, 기존의 물리적인 데이터센터(서버)를 운용하는 것. 2) 운영 비용 절감고정된 서버는 최대 트래픽치를 예상하여 구축합니다. 때문에 트래픽이 줄었을 경우에는 자원의 낭비가 발생하고, 수용 범위를 초과한 경우에는 서비스가 느려지거나 중단되는 등의 문제가 발생합니다. On and Off 서버가 중지되고 있는 시간 만큼 자원의 낭비가 발생합니다. Fast Growth 빠른 성장으로 사용자의 유입이 늘어난다면, 적지 않은 비용을 들여 성능 향상을 해주어야 합니다. 미래의 트래픽을 예상하기 힘들고, 비용문제로 잦은 성능 향상은 부담입니다. Variable peaks 유동적인 트래픽 대응하기 어렵습니다. 서버의 성능이 낮다면 많은 사용자를 수용할 수 없고, 성능이 과하게 좋다면 자원의 낭비가 될 수 있습니다. Predictable peaks 트래픽이 많은 일정 시간대(게다가 예상할 수 있는)만을 위한 서버 능력은 자원의 낭비가 될 수 있습니다. 전력, 항온항습, 상면 비용 등의 물리적인 데이터센터를 유지하는 비용과 이를 운영, 관리하는 인력에 소모되는 비용, 소프트웨어의 버전 업에 따른 라이선스 변경과 그 비용, 그리고 향후에 서버를 증설하는 비용까지 On-premise 방식에는 운영하는데 신경 써야 할 요소가 많습니다. 3) 탄력적인 운영 및 확장트래픽의 변동에 유연하게 대응할 수 있습니다. 이는 서버의 안정성이 늘어남에 따라 사용자에게 만족감을 줄 수 있을뿐더러, 서버를 효율적으로 운영하여 비용절감이 가능합니다. 4) 속도 및 민첩성적은 비용으로 손쉽게 애플리케이션을 배포가 가능하기 때문에 서비스 구현 속도가 빨라지고, 더 많은 시도를 할 수 있습니다. On-premises vs Cloud Computing(AWS) 혁신을 위한 시도가 자주 일어나지 않는다 ↔ 혁신을 위한 시도를 많이 할 수 있다 실패의 비용이 높다 ↔ 실패의 비용이 낮다 혁신의 속도가 느려진다 ↔ 많은 혁신이 가능하다 5) 비즈니에스에만 집중 가능서버의 운영부터, 보안, 라이센스, 증설 및 확장 등의 문제에 대해서 자유로워질 수 있습니다. 6) 글로벌 확장전용 데이터센터가 전세계 곳곳에 구축되어 있기 때문에, 따로 데이터 센터를 구축 할 필요 없이 손쉽게 글로벌 서비스가 가능합니다. Reference https://www.youtube.com/watch?v=KBzkeuX32XY https://aws.amazon.com/ko/blogs/korea/tag/webinar/","categories":[{"name":"Study","slug":"study","permalink":"https://delf-lee.github.io/categories/study/"}],"tags":[{"name":"Cloud","slug":"cloud","permalink":"https://delf-lee.github.io/tags/cloud/"},{"name":"Interview","slug":"interview","permalink":"https://delf-lee.github.io/tags/interview/"},{"name":"AWS","slug":"aws","permalink":"https://delf-lee.github.io/tags/aws/"}]},{"title":"객체지향(Object-Oriented)이란?","slug":"post/object-oriented","date":"2018-09-13T10:49:41.000Z","updated":"2018-10-19T16:20:17.862Z","comments":true,"path":"post/object-oriented/","link":"","permalink":"https://delf-lee.github.io/post/object-oriented/","excerpt":"","text":"객체지향(Object-Oriented)이란?객체(Object) 현실세계의 실체 및 개념을 반영하는 상태(Status)와 행위(Behavior)를 정의한 데이터의 집합 객체지향(Object-Oriented) 프로그래밍 각자의 역할을 지닌 객체들끼리 서로 메시지를 주고받으며 동작할 수 있도록 프로그래밍 하는 것 객체지향의 장점(강점)객체를 중심으로 프로그래밍하기 때문에, 사람의 관점에서 프로그램을 이해하고 파악하기 쉽다. 강한 응집력(Strong Cohesion)과 약한 결합력(Weak Coupling)을 가진다. 재사용성, 확장성, 융통성이 높다. 이러한 장점 때문에 디버깅과 유지보수가 용이하고 설계과 분석이 비교적 쉽다. 객체지향의 단점(한계) 객체 간의 정보 교환이 모두 메시지 교환을 통해 일어나므로 실행 시스템에 많은 overhead가 발생하게 된다. 처리속도가 상대적으로 느리다. 하지만 하드웨어의 발전으로 이러한 단점은 어느정도 해소되었다. 객체가 상태를 갖기 때문에 예상치 못한 부작용이 발생할 수 있다. 변수가 존재하고 이 변수를 통해 객체가 예측할 수 없는 상태를 갖게 되어 애플리케이션 내부에서 버그를 발생시킬 수 있다. 이는 함수형 프로그래밍 등장의 패러다임이다. 객체지향적 설계원칙 SOLID SRP(Single Responsibility Principle)단일 책임 원칙 클래스는 단 하나의 책임을 가져야 하며 클래스를 변경하는 이유는 단 하나의 이유이어야 한다. OCP(Open-Closed Principle) : 개방-폐쇄 원칙 확장에는 열려 있어야 하고 변경에는 닫혀 있어야 한다. LSP(Liskov Substitution Principle) : 리스코프 치환 원칙 상위 타입의 객체를 하위 타입의 객체로 치환해도 상위 타입을 사용하는 프로그램은 정상적으로 동작해야 한다. ISP(Interface Segregation Principle) : 인터페이스 분리 원칙 인터페이스는 그 인터페이스를 사용하는 클라이언트를 기준으로 분리해야 한다. DIP(Dependency Inversion Principle) : 의존 역전 원칙 고수준 모듈은 저수준 모듈의 구현에 의존해서는 안된다. 객체지향의 특징추상화 객체에서 공통된 속성이나 기능을 추출하는 것. 중요하지 않은 것(관심 대상이 아닌 것)은 감추거나 무시하고, 중요한 것(관심있는 것)만을 강조하여 추출하는 것. 관점에 따라 추상화의 결과가 달라질 수 있다. 주요 관심사에만 집중함으로써, 프로그램의 복잡도를 관리할 수 있다. 캡슐화관심있는 데이터와 기능을 모아놓고 패킹한 것이다. 객체지향에서는 이를 클래스로 정의하고 외부에서 마음대로 접근할 수 없게하였다. 과거 절차지향 프로그래밍에서는 소스코드가 거대해질수록 데이터가 어디서 어떻게 변화하는지 파악하기 어려웠고 유지보수가 힘들어지는 문제가 발생하였다. 객체지향 프로그래밍에서는 캡슐화를 통해 이란 폐단을 해결하였다. 이렇게 내부의 데이터나 함수를 외부에서 참조하지 못하도록 차단하는 개념을 정보 은닉화(Information Hiding)라고 하며 이것이 바로 캡슐화라는 개념이다. 다형성같은 코드라 하더라도 상황에 따라 다른 방식으로 동작하는 성질. Java에서 다형성을 구현할 수 있는 대표적으로 Overriding과 Overloading이 있다. Overriding임의의 클래스가 다른 클래스를 상속 받거나 인터페이스를 구현했을 때, 상위 클래스 또는 인터페이스에 정의되어 있는 메소드를 재정의 하여 사용하는 것이다. 메소드 호출 시 재정의되어 있지 않다면 상위 클래스의 메소드가 호출된다. (인터페이스는 오버라이딩이 강제된다.) Overloading메소드에 주어진 인자(parameter)에 따라 동작을 다르게 구현할 수 있다. 코드의 중복이 줄어들고, 가독성이 늘어난다. 반환 형(return type)은 관계가 없지만, 인자의 개수, 인자의 타입에 따라 다르게 구현할 수 있다. 상속부모의 형질을 이어받는다는 의미로, 부모 클래스의 속성과 메소드를 그대로 활용할 수 있다. 여기에 더해 새로운 속성과 메소드를 추가할 수 있으며 같은 메소드라 하더라도 오버라이딩(Overriding)을 통하여 재정의하여 다르게 동작하게끔 할 수 있다. 손쉽게 클래스를 재활용할 수 있으며, 부모가 같은 클래스들을 동시에 처리하기 용이하다. 클래스(class)객체를 만들기 위해 상태(field)와 행위(method)를 정의한 틀. 메시지객체지향적으로 구현된 프로그램은 객체들끼리의 메시지를 주고받고 상호작용하며 동작한다. 코드적으로는 임의의 객체에게 인자(parameter)를 전달하여 메소드를 호출하며 반환값(return value)을 받아 처리를 한다. Reference https://github.com/JaeYeopHan/Interview_Question_for_Beginner/tree/master/Development_common_sense#object-oriented-programming https://ko.wikipedia.org/wiki/객체_지향_프로그래밍 http://asfirstalways.tistory.com/177","categories":[{"name":"Study","slug":"study","permalink":"https://delf-lee.github.io/categories/study/"}],"tags":[{"name":"Interview","slug":"interview","permalink":"https://delf-lee.github.io/tags/interview/"},{"name":"OOP","slug":"oop","permalink":"https://delf-lee.github.io/tags/oop/"}]},{"title":"Cloud Computing이란?","slug":"post/cloud-computing","date":"2018-09-11T08:26:12.000Z","updated":"2018-10-19T16:20:17.861Z","comments":true,"path":"post/cloud-computing/","link":"","permalink":"https://delf-lee.github.io/post/cloud-computing/","excerpt":"","text":"개요 클라우드 컴퓨팅이란? 클라우드 컴퓨팅의 등장배경 클라우드 컴퓨팅의 정의 클라우드 컴퓨팅의 특징 클라우드 컴퓨팅 서비스 모델 클라우드 컴퓨팅의 장-단점 클라우드 안정성과 신뢰성 클라우드 도입 1. 클라우드 컴퓨팅이란? 인터넷 ‘너머’에 존재하는 클라우드 사업자의 컴퓨터에서 정보처리를 하는 서비스 특정 기술이 아닌, 사고 방식 또는 개념(모델) 초기 투자나 장기 계약 없이 인터넷을 통해 IT 리소스와 애플리케이션을 원할 때 언제든지(On-demand) 사용할 수 있고 사용한 만큼 요금을 내는 서비스 2. 클라우드 컴퓨팅의 등장배경정보처리 시스템의 흐름 메인프레임 - 1980년대 분산형 클라이언트 서버 모델- 1990년대 사내 인트라넷 → 서버에 집중 - 2000년대 클라우드 컴퓨팅 - 2010년대 전 세계에 분산 배치된 서버 리소스를 필요한 때 필요한 만큼 사용 정보처리 시스템의 흐름 CPU 고속화 가상화 기술 및 분산 처리 기술 빠르고 저렴한 네트워크 거대해진 데이터 센터 사용자(기업) - IT 투자 비용 절감 사업자(클라우드 서비스 제공자) - 지속적 매출 3. 클라우드 정의NIST (미국 국립 표준 기술연구소) 정의 - www.ipa.go.jp/files/000025366.pdf 공유 구성이 가능한 컴퓨팅 리소스의 통합을 통해 어디서나 간편하게, 요청에 따라 네트워크를 통해 접근하는 것을 가능하게 하는 모델. 이는 최소한의 이용 절차 또는 서비스 공급자의 상호 작용을 통해, 신속히 할당되어 제공된다. 4. 클라우드 특징 주문형 셀프 서비스 - 사용자 스스로 개별 관리 광범위한 네트워크 접속 리소스 공유 신속한 확장성 - Scale Up/Down 측정 가능한 서비스 - 종량제 5. 클라우드 서비스 모델 IaaS (Infrastructure as a Service) Paas (Platform as a Service) Saas (Software as a Service) 참고: https://www.ibm.com/cloud/learn/iaas-paas-saas IaaS (Infrastructure as a Service) 사업자는 사용자에게 pay-as-you-go access 제공 Storage, Networking, Servers, … PaaS (Platform as a Service) 사업자는 Cloud-based environment + Infrastructure 제공 사용자는 Application 개발 Java, PHP, Ruby 등의 프로그래밍 언어를 지원하는 애플리케이션 실행 환경이나 데이터베이스 등이 미리 준비되어 있음 개발 및 테스트에 큰 처리 능력이 필요한 경우 자사에서 운영 중인 애플리케이션의 최대 부하를 분산 처리할 때 IoT 데이터를 효율적으로 수집하여 처리하는 플랫폼 Force.com SaaS (Software as a Service) 사업자는 사용자에게 software/application 제공 사용자는 subscrible를 하고 web 또는 API를 통해 access 클라우드 서비스 모델 참고 - from MS MS Azure IaaS란? MS Azure PaaS란? MS Azure SaaS란? Cloud Service ⟺︎ On-premise 회사 내에 자체적으로 데이터 센터를 보유 시스템 구축, 운용까지 직접 수행하는 형태 6-1. 클라우드 컴퓨팅의 장점 경제성: 사용하고자 하는 기간만, 소프트웨어/데이터를 클라우드에서 통합 관리 유연성: 리소스를 필요할 때, 필요한 만큼 확장/축소 가능 가용성: 장애 발생시 계속 사용 가능 빠른 구축 속도 손쉬운 글로벌 서비스(ex. 넷마블의 해외 서바스) 강력한 보안 6-2. 클라우드 컴퓨팅의 단점 생각보다 비싼 비용 점점 커지는 클라우드 의존성 데이터 보관의 불안함 클라우드 이용 모델 Deployment model Private cloud Community cloud Public cloud Hybrid cloud Private cloud 독점적으로 사용되는 클라우드 컴퓨팅 리소스 클라우드 서비스 사용자 또는 사업자의 데이터 센터에 구축한 자사 전용 환경 서비스와 인프라가 개인/기업네트워크에서 유지 관리 됨 Community cloud 공통의 목적을 가진 기업/조직들이 클라우드 시스템을 형성하여 데이터 센터에서 공동 운영하는 형태 Public cloud 클라우드 사업자가 시스템 구축 네트워크를 통해 기업, 개인에게 서비스 제공 기업/개인 방화벽 외부에 구축됨 Hybrid cloud Public, Private, Community 서비스들과 On-premise 시스템을 연계시켜 활용하는 시스템 Private cloud 종류 On-premise private cloud 자사 전용 클라우드 환경 구축, 운용 자체적인 보안정책 → 강력한 보안 환경 부담 Hosted private cloud 클라우드 사업자가 기업 사용자별로 클라우드 환경 제공 기업 전용 클라우드 환경 구축 → 비용 지불 클라우드의 안정성과 신뢰성 클라우드 리스크 장비 고장 리스크 재해, 운영자의 조작 실수 등의 리스크 통신 도청 리스크 중간자 공격 스푸핑 클라우드 사업자의 파산 또는 서비스 중단…클라우드의 보안 거버넌스 기업 경영진이 클라우드를 이용할 때의 위험을 주체적이고 적절하게 관리하기 위한 구조를 구축하고 운용하는 것 보안 등의 리스크를 모두 통제할 수 없다 → 클라우드 서비스의 연속성 리스크 8. 클라우드 도입중소기업의 클라우드 도입 중소기업의 IT 활용 부진의 요인 - 비용, 인재의 부족 클라우드 도입의 장점: 기업의 가치 창출, 성장에 대비 정보 시스템 담당자 비용 절약 시장 환경 변화에 따라 유연하게 시스템을 변화시킬 수 있음 경영진 IT에 투자하는 경영 자원의 최소화 핵심 역량에 경영 자원 집중 가능 대기업의 클라우드 도입 세계 시장 진출시 손쉬운 글로벌화 글로벌하게 전개할 수 있는 효율적인 업무 프로세스 구조 구축 신속한 시스템 도입 및 운영으로부터의 해방","categories":[{"name":"Study","slug":"study","permalink":"https://delf-lee.github.io/categories/study/"}],"tags":[{"name":"Cloud","slug":"cloud","permalink":"https://delf-lee.github.io/tags/cloud/"}]},{"title":"Java의 Comparable과 Comparator","slug":"post/comparable-and-comparator","date":"2018-09-02T13:36:05.000Z","updated":"2018-10-19T16:20:17.862Z","comments":true,"path":"post/comparable-and-comparator/","link":"","permalink":"https://delf-lee.github.io/post/comparable-and-comparator/","excerpt":"","text":"개요 배열 안의 요소 정렬 객체들의 정렬 Comparable interface Comparator interface 예제 1. 배열의 안의 요소 정렬배열 안의 요소는 Java API에서 제공하는 sort()메서드를 이용하면 쉽게 정렬이 가능합니다.int[] nums = &#123;4, 1, 3, 2, 5&#125;;Arrays.sort(nums); // 결과: 1, 2, 3, 4, 5String[] strs = &#123;\"D\", \"A\", \"B\", \"E\", \"C\"&#125;;Arrays.sort(strs); // 결과: \"A\", \"B\", \"C\", \"D\", \"E\" 이렇게 정렬이 가능한 이유는 각 요소를 비교할 수 있기 때문입니다. 1보다는 2가 크고, A보다는 B가 크죠. 하지만 아래와 같은 Student 인스턴스가 여러게 있다면, 과연 어떤게 ‘먼저’ 일까요?public class Student &#123; public String name; public int age; ...&#125; 2. 객체들의 정렬사용자가 생성한 임의의 객체들을 정렬하기 위해서는 기준이 필요합니다. 즉 객체의 비교가 가능하다면 정렬을 할 수 있게됩니다.어떤게 더 큰지, 어떤게 더 먼저인지 비교가 가능하다면, 그 기준에 따라 정렬이 가능하죠. Comparable interface그 기준을 정의하기 위해서는 해당 class에 Comparable interface를 구현현하는 방법 이 있습니다. CompareTo()메소드를 오버라이드 하여 인스턴스에 대하여 비교 기준을 정의해야 합니다. Comparable은 정렬 수행시 기본적으로 적용되는 정렬 기준이 되는 메서드를 정의해 놓는 인터페이스입니다. 사실, 위에서 Arrays를 이용하여 정렬한 배열안의 요소(객체)를 포함한 대부분의 Java의 기본 자료형들은 Comparable interface를 구현하고 있습니다. // Integer classpublic final class Integer extends Number implements Comparable&lt;Integer&gt; &#123; ...&#125;// String classpublic final class String implements java.io.Serializable, Comparable&lt;String&gt;, CharSequence &#123; ...&#125; Comparable interface를 구현하여 Student의 객체들을 나이(age)순으로 정렬하고자 한다면, 다음과 같이 정의할 수 있습니다.public class Student implements Comparable&lt;Student&gt; &#123; public String name; public int age; ... @Override public int compareTo(Student o) &#123; return Integer.compare(this.age, o.age); &#125;&#125; CompareTo()의 반환값이 양수라면 내부 정렬 알고리즘에서 두 요소를 비교할 때 자리를 바꾸고, 0이나 음수라면 바꾸지 않습니다. Student[] arr = new Student[5];arr[0] = new Student(\"A\", 26);arr[1] = new Student(\"B\", 27);arr[2] = new Student(\"C\", 27);arr[3] = new Student(\"D\", 21);arr[4] = new Student(\"E\", 20);List&lt;Student&gt; students = new ArrayList&lt;&gt;();for (Student student : arr) students.add(student);// 기본 배열에서의 정렬Arrays.sort(arr); // 결과: E(20), D(21), B(27), A(26), C(27)// List Collection에서의 정렬Collections.sort(students); // 결과: E(20), D(21), B(27), A(26), C(27) Comparator interface그렇다면 Student 객체들을 이름 순으로 정렬하고 싶다면? 나이 내림차순으로 정리하고 싶다면 어떡할까요?정렬할 때 마다 Student class의 코드를 수정해야할까요? 이럴 때 쓰이는 것이 바로 Comparator interface입니다. Comparator는 기본 정렬 기준(Comparable을 구현하여 정의한 기준)과는 다른 방식으로 정렬하고 싶을 때 사용하는 인터페이스입니다. 다른 기준의 정렬 조건을 정의하기 위해선 Comparator를 interface를 구현하고 compare()메서드를 작성해야 합니다. 여기서는 간단하게 익명 클래스(Anonymouse class)로 구현하겠습니다.Student[] arr = new Student[5];arr[0] = new Student(\"A\", 26);arr[1] = new Student(\"B\", 27);arr[2] = new Student(\"C\", 27);arr[3] = new Student(\"D\", 21);arr[4] = new Student(\"E\", 20);List&lt;Student&gt; students = new ArrayList&lt;&gt;();for (Student student : arr) students.add(student);/* Comparator 익명클래스 정의 */Comparator&lt;Student&gt; descNameComparator = new Comparator&lt;Student&gt;() &#123; @Override public int compare(Student s1, Student s2) &#123; return s2.name.compareTo(s1.name); // 이름에 대하여 내림차순 &#125;&#125;;// 기본 배열에서의 정렬Arrays.sort(arr, descNameComparator); // 결과: E(20), D(21), C(27), B(24), A(26)// List Collection에서의 정렬Collections.sort(stdents, descNameComparator); // 결과: E(20), D(21), C(27), B(24), A(26) 이름을 내림차순으로 정렬하기 위하여 String의 비교 값을 출력하였습니다. 이와 같이 Comparator 인터페이스를 구현하면, 임의의 사용자 객체에 대하여 여러 종류의 기준으로 정렬이 가능합니다. 조건문을 통해 compare()메서드의 반환값을 제어해 준다면 정렬 기준을 중복하여 적용할 수 있습니다. 이는 Comparable 인터페이스의 compareTo()메서드도 마찬가지입니다.// 나이 역순으로 정렬. 나이가 같다면 이름순으로 정렬.Comparator&lt;Student&gt; myComparator = new Comparator&lt;Student&gt;() &#123; @Override public int compare(Student s1, Student s2) &#123; if(s1.age == s2.age) &#123; return s1.name.compareTo(s2.name); &#125; return Integer.compare(s2.age, s1.age); &#125;&#125;; 3. 예제위 설명을 기반으로 한 예제 코드입니다.import java.util.*;public class Main &#123; public static void main(String args[]) &#123; // Student 배열 인스턴스 생성 Student[] arr = new Student[5]; arr[0] = new Student(\"A\", 26); arr[1] = new Student(\"B\", 27); arr[2] = new Student(\"C\", 27); arr[3] = new Student(\"D\", 21); arr[4] = new Student(\"E\", 20); // Student List Collection 인스턴스 생성 List&lt;Student&gt; students = new ArrayList&lt;&gt;(); for (Student student : arr) students.add(student); // 기본 배열에서의 정렬(Comparable interface) Arrays.sort(arr); System.out.println(Arrays.asList(arr)); // E(20), D(21), B(27), A(26), C(27) // List Collection에서의 정렬(Comparable interface) Collections.sort(students); System.out.println(students); // E(20), D(21), B(27), A(26), C(27) System.out.println(); /* Comparator 익명클래스 정의 */ Comparator&lt;Student&gt; descNameComparator = new Comparator&lt;Student&gt;() &#123; @Override public int compare(Student s1, Student s2) &#123; return s2.name.compareTo(s1.name); // 이름에 대하여 내림차순 &#125; &#125;; // 기본 배열에서의 정렬(Comparator interface) Arrays.sort(arr, descNameComparator); System.out.println(Arrays.asList(arr)); // E(20), D(21), C(27), B(27), A(26) // List Collection에서의 정렬(Comparator interface) Collections.sort(students, descNameComparator); System.out.println(students); // E(20), D(21), C(27), B(27), A(26) &#125;&#125;class Student implements Comparable&lt;Student&gt; &#123; public String name; public int age; public Student(String name, int age) &#123; this.name = name; this.age = age; &#125; @Override public int compareTo(Student o) &#123; return Integer.compare(this.age, o.age); // 나이에 대하여 오름차순 &#125; @Override public String toString() &#123; return name + \"(\" + age + \")\"; &#125;&#125; Reference http://hochulshin.com/java-comparable-comparator/ http://cwondev.tistory.com/15 https://docs.oracle.com/javase/8/docs/api/java/lang/Comparable.html https://docs.oracle.com/javase/8/docs/api/java/util/Comparator.html","categories":[],"tags":[{"name":"Java","slug":"java","permalink":"https://delf-lee.github.io/tags/java/"}]}]}