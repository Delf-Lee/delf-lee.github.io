{"meta":{"title":"Delf's blog","subtitle":null,"description":null,"author":"Delf","url":"https://delf-lee.github.io"},"pages":[{"title":"","date":"2018-08-28T18:02:18.186Z","updated":"2018-08-28T17:22:09.979Z","comments":true,"path":"index.html","permalink":"https://delf-lee.github.io/index.html","excerpt":"","text":"this is index.md"},{"title":"","date":"2018-08-26T06:37:25.404Z","updated":"2018-08-26T06:37:25.404Z","comments":true,"path":"about/index.html","permalink":"https://delf-lee.github.io/about/index.html","excerpt":"","text":""}],"posts":[{"title":"Cloud Computing이란?","slug":"Cloud-Computing","date":"2018-09-11T08:26:12.000Z","updated":"2018-09-11T08:55:18.940Z","comments":true,"path":"2018-09/Cloud-Computing/","link":"","permalink":"https://delf-lee.github.io/2018-09/Cloud-Computing/","excerpt":"","text":"개요 클라우드 컴퓨팅이란? 클라우드 컴퓨팅의 등장배경 클라우드 컴퓨팅의 정의 클라우드 컴퓨팅의 특징 클라우드 컴퓨팅 서비스 모델 클라우드 컴퓨팅의 장-단점 클라우드 안정성과 신뢰성 클라우드 도입 1. 클라우드 컴퓨팅이란? 인터넷 ‘너머’에 존재하는 클라우드 사업자의 컴퓨터에서 정보처리를 하는 서비스 특정 기술이 아닌, 사고 방식 또는 개념(모델) 초기 투자나 장기 계약 없이 인터넷을 통해 IT 리소스와 애플리케이션을 원할 때 언제든지(On-demand) 사용할 수 있고 사용한 만큼 요금을 내는 서비스 2. 클라우드 컴퓨팅의 등장배경정보처리 시스템의 흐름 메인프레임 - 1980년대 분산형 클라이언트 서버 모델- 1990년대 사내 인트라넷 → 서버에 집중 - 2000년대 클라우드 컴퓨팅 - 2010년대 전 세계에 분산 배치된 서버 리소스를 필요한 때 필요한 만큼 사용 정보처리 시스템의 흐름 CPU 고속화 가상화 기술 및 분산 처리 기술 빠르고 저렴한 네트워크 거대해진 데이터 센터 (delf: 클라우드 서비스에 종속?) 사용자(기업) - IT 투자 비용 절감 사업자(클라우드 서비스 제공자) - 지속적 매출 3. 클라우드 정의NIST (미국 국립 표준 기술연구소) 정의 - www.ipa.go.jp/files/000025366.pdf 공유 구성이 가능한 컴퓨팅 리소스의 통합을 통해 어디서나 간편하게, 요청에 따라 네트워크를 통해 접근하는 것을 가능하게 하는 모델. 이는 최소한의 이용 절차 또는 서비스 공급자의 상호 작용을 통해, 신속히 할당되어 제공된다. 4. 클라우드 특징 주문형 셀프 서비스 - 사용자 스스로 개별 관리 광범위한 네트워크 접속 리소스 공유 (delf: 가상화 기술) 신속한 확장성 - Scale Up/Down 측정 가능한 서비스 - 종량제 5. 클라우드 서비스 모델 IaaS (Infrastructure as a Service) Paas (Platform as a Service) Saas (Software as a Service) 참고: https://www.ibm.com/cloud/learn/iaas-paas-saas IaaS (Infrastructure as a Service) 사업자는 사용자에게 pay-as-you-go access 제공 Storage, Networking, Servers, … PaaS (Platform as a Service) 사업자는 Cloud-based environment + Infrastructure 제공 사용자는 Application 개발 Java, PHP, Ruby 등의 프로그래밍 언어를 지원하는 애플리케이션 실행 환경이나 데이터베이스 등이 미리 준비되어 있음 개발 및 테스트에 큰 처리 능력이 필요한 경우 자사에서 운영 중인 애플리케이션의 최대 부하를 분산 처리할 때 IoT 데이터를 효율적으로 수집하여 처리하는 플랫폼 Force.com SaaS (Software as a Service) 사업자는 사용자에게 software/application 제공 사용자는 subscrible를 하고 web 또는 API를 통해 access 클라우드 서비스 모델 참고 - from MS MS Azure IaaS란? MS Azure PaaS란? MS Azure SaaS란? Cloud Service ⟺︎ On-premise 회사 내에 자체적으로 데이터 센터를 보유 시스템 구축, 운용까지 직접 수행하는 형태 6-1. 클라우드 컴퓨팅의 장점 경제성: 사용하고자 하는 기간만, 소프트웨어/데이터를 클라우드에서 통합 관리 유연성: 리소스를 필요할 때, 필요한 만큼 확장/축소 가능 가용성: 장애 발생시 계속 사용 가능 빠른 구축 속도 손쉬운 글로벌 서비스(ex. 넷마블의 해외 서바스) 강력한 보안 6-2. 클라우드 컴퓨팅의 단점 생각보다 비싼 비용 점점 커지는 클라우드 의존성 데이터 보관의 불안함 클라우드 이용 모델 Deployment model Private cloud Community cloud Public cloud Hybrid cloud Private cloud 독점적으로 사용되는 클라우드 컴퓨팅 리소스 클라우드 서비스 사용자 또는 사업자의 데이터 센터에 구축한 자사 전용 환경 서비스와 인프라가 개인/기업네트워크에서 유지 관리 됨 Community cloud 공통의 목적을 가진 기업/조직들이 클라우드 시스템을 형성하여 데이터 센터에서 공동 운영하는 형태 Public cloud 클라우드 사업자가 시스템 구축 네트워크를 통해 기업, 개인에게 서비스 제공 기업/개인 방화벽 외부에 구축됨 Hybrid cloud Public, Private, Community 서비스들과 On-premise 시스템을 연계시켜 활용하는 시스템 Private cloud 종류 On-premise private cloud 자사 전용 클라우드 환경 구축, 운용 자체적인 보안정책 → 강력한 보안 환경 부담 Hosted private cloud 클라우드 사업자가 기업 사용자별로 클라우드 환경 제공 기업 전용 클라우드 환경 구축 → 비용 지불 클라우드의 안정성과 신뢰성 클라우드 리스크 장비 고장 리스크 재해, 운영자의 조작 실수 등의 리스크 통신 도청 리스크 중간자 공격 스푸핑 클라우드 사업자의 파산 또는 서비스 중단…클라우드의 보안 거버넌스 기업 경영진이 클라우드를 이용할 때의 위험을 주체적이고 적절하게 관리하기 위한 구조를 구축하고 운용하는 것 보안 등의 리스크를 모두 통제할 수 없다 → 클라우드 서비스의 연속성 리스크 8. 클라우드 도입중소기업의 클라우드 도입 중소기업의 IT 활용 부진의 요인 - 비용, 인재의 부족 클라우드 도입의 장점: 기업의 가치 창출, 성장에 대비 정보 시스템 담당자 비용 절약 시장 환경 변화에 따라 유연하게 시스템을 변화시킬 수 있음 경영진 IT에 투자하는 경영 자원의 최소화 핵심 역량에 경영 자원 집중 가능 대기업의 클라우드 도입 세계 시장 진출시 손쉬운 글로벌화 글로벌하게 전개할 수 있는 효율적인 업무 프로세스 구조 구축 신속한 시스템 도입 및 운영으로부터의 해방","categories":[{"name":"Study","slug":"study","permalink":"https://delf-lee.github.io/categories/study/"}],"tags":[{"name":"Cloud","slug":"cloud","permalink":"https://delf-lee.github.io/tags/cloud/"}]},{"title":"Java의 Comparable과 Comparator","slug":"Comparable-and-Comparator","date":"2018-09-02T13:36:05.000Z","updated":"2018-09-11T08:43:09.268Z","comments":true,"path":"2018-09/Comparable-and-Comparator/","link":"","permalink":"https://delf-lee.github.io/2018-09/Comparable-and-Comparator/","excerpt":"","text":"개요 배열 안의 요소 정렬 객체들의 정렬 Comparable interface Comparator interface 예제 1. 배열의 안의 요소 정렬배열 안의 요소는 Java API에서 제공하는 sort()메서드를 이용하면 쉽게 정렬이 가능합니다.12345int[] nums = &#123;4, 1, 3, 2, 5&#125;;Arrays.sort(nums); // 결과: 1, 2, 3, 4, 5String[] strs = &#123;\"D\", \"A\", \"B\", \"E\", \"C\"&#125;;Arrays.sort(strs); // 결과: \"A\", \"B\", \"C\", \"D\", \"E\" 이렇게 정렬이 가능한 이유는 각 요소를 비교할 수 있기 때문입니다. 1보다는 2가 크고, A보다는 B가 크죠. 하지만 아래와 같은 Student 인스턴스가 여러게 있다면, 과연 어떤게 ‘먼저’ 일까요?12345public class Student &#123; public String name; public int age; ...&#125; 2. 객체들의 정렬사용자가 생성한 임의의 객체들을 정렬하기 위해서는 기준이 필요합니다. 즉 객체의 비교가 가능하다면 정렬을 할 수 있게됩니다.어떤게 더 큰지, 어떤게 더 먼저인지 비교가 가능하다면, 그 기준에 따라 정렬이 가능하죠. Comparable interface그 기준을 정의하기 위해서는 해당 class에 Comparable interface를 구현현하는 방법 이 있습니다. CompareTo()메소드를 오버라이드 하여 인스턴스에 대하여 비교 기준을 정의해야 합니다. Comparable은 정렬 수행시 기본적으로 적용되는 정렬 기준이 되는 메서드를 정의해 놓는 인터페이스입니다. 사실, 위에서 Arrays를 이용하여 정렬한 배열안의 요소(객체)를 포함한 대부분의 Java의 기본 자료형들은 Comparable interface를 구현하고 있습니다. 12345678910// Integer classpublic final class Integer extends Number implements Comparable&lt;Integer&gt; &#123; ...&#125;// String classpublic final class String implements java.io.Serializable, Comparable&lt;String&gt;, CharSequence &#123; ...&#125; Comparable interface를 구현하여 Student의 객체들을 나이(age)순으로 정렬하고자 한다면, 다음과 같이 정의할 수 있습니다.123456789public class Student implements Comparable&lt;Student&gt; &#123; public String name; public int age; ... @Override public int compareTo(Student o) &#123; return Integer.compare(this.age, o.age); &#125;&#125; CompareTo()의 반환값이 양수라면 내부 정렬 알고리즘에서 두 요소를 비교할 때 자리를 바꾸고, 0이나 음수라면 바꾸지 않습니다. 1234567891011121314151617Student[] arr = new Student[5];arr[0] = new Student(\"A\", 26);arr[1] = new Student(\"B\", 27);arr[2] = new Student(\"C\", 27);arr[3] = new Student(\"D\", 21);arr[4] = new Student(\"E\", 20);List&lt;Student&gt; students = new ArrayList&lt;&gt;();for (Student student : arr) students.add(student);// 기본 배열에서의 정렬Arrays.sort(arr); // 결과: E(20), D(21), B(27), A(26), C(27)// List Collection에서의 정렬Collections.sort(students); // 결과: E(20), D(21), B(27), A(26), C(27) Comparator interface그렇다면 Student 객체들을 이름 순으로 정렬하고 싶다면? 나이 내림차순으로 정리하고 싶다면 어떡할까요?정렬할 때 마다 Student class의 코드를 수정해야할까요? 이럴 때 쓰이는 것이 바로 Comparator interface입니다. Comparator는 기본 정렬 기준(Comparable을 구현하여 정의한 기준)과는 다른 방식으로 정렬하고 싶을 때 사용하는 인터페이스입니다. 다른 기준의 정렬 조건을 정의하기 위해선 Comparator를 interface를 구현하고 compare()메서드를 작성해야 합니다. 여기서는 간단하게 익명 클래스(Anonymouse class)로 구현하겠습니다.1234567891011121314151617181920212223Student[] arr = new Student[5];arr[0] = new Student(\"A\", 26);arr[1] = new Student(\"B\", 27);arr[2] = new Student(\"C\", 27);arr[3] = new Student(\"D\", 21);arr[4] = new Student(\"E\", 20);List&lt;Student&gt; students = new ArrayList&lt;&gt;();for (Student student : arr) students.add(student);/* Comparator 익명클래스 정의 */Comparator&lt;Student&gt; descNameComparator = new Comparator&lt;Student&gt;() &#123; @Override public int compare(Student s1, Student s2) &#123; return s2.name.compareTo(s1.name); // 이름에 대하여 내림차순 &#125;&#125;;// 기본 배열에서의 정렬Arrays.sort(arr, descNameComparator); // 결과: E(20), D(21), C(27), B(24), A(26)// List Collection에서의 정렬Collections.sort(stdents, descNameComparator); // 결과: E(20), D(21), C(27), B(24), A(26) 이름을 내림차순으로 정렬하기 위하여 String의 비교 값을 출력하였습니다. 이와 같이 Comparator 인터페이스를 구현하면, 임의의 사용자 객체에 대하여 여러 종류의 기준으로 정렬이 가능합니다. 조건문을 통해 compare()메서드의 반환값을 제어해 준다면 정렬 기준을 중복하여 적용할 수 있습니다. 이는 Comparable 인터페이스의 compareTo()메서드도 마찬가지입니다.12345678910// 나이 역순으로 정렬. 나이가 같다면 이름순으로 정렬.Comparator&lt;Student&gt; myComparator = new Comparator&lt;Student&gt;() &#123; @Override public int compare(Student s1, Student s2) &#123; if(s1.age == s2.age) &#123; return s1.name.compareTo(s2.name); &#125; return Integer.compare(s2.age, s1.age); &#125;&#125;; 3. 예제위 설명을 기반으로 한 예제 코드입니다.12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364import java.util.*;public class Main &#123; public static void main(String args[]) &#123; // Student 배열 인스턴스 생성 Student[] arr = new Student[5]; arr[0] = new Student(\"A\", 26); arr[1] = new Student(\"B\", 27); arr[2] = new Student(\"C\", 27); arr[3] = new Student(\"D\", 21); arr[4] = new Student(\"E\", 20); // Student List Collection 인스턴스 생성 List&lt;Student&gt; students = new ArrayList&lt;&gt;(); for (Student student : arr) students.add(student); // 기본 배열에서의 정렬(Comparable interface) Arrays.sort(arr); System.out.println(Arrays.asList(arr)); // E(20), D(21), B(27), A(26), C(27) // List Collection에서의 정렬(Comparable interface) Collections.sort(students); System.out.println(students); // E(20), D(21), B(27), A(26), C(27) System.out.println(); /* Comparator 익명클래스 정의 */ Comparator&lt;Student&gt; descNameComparator = new Comparator&lt;Student&gt;() &#123; @Override public int compare(Student s1, Student s2) &#123; return s2.name.compareTo(s1.name); // 이름에 대하여 내림차순 &#125; &#125;; // 기본 배열에서의 정렬(Comparator interface) Arrays.sort(arr, descNameComparator); System.out.println(Arrays.asList(arr)); // E(20), D(21), C(27), B(27), A(26) // List Collection에서의 정렬(Comparator interface) Collections.sort(students, descNameComparator); System.out.println(students); // E(20), D(21), C(27), B(27), A(26) &#125;&#125;class Student implements Comparable&lt;Student&gt; &#123; public String name; public int age; public Student(String name, int age) &#123; this.name = name; this.age = age; &#125; @Override public int compareTo(Student o) &#123; return Integer.compare(this.age, o.age); // 나이에 대하여 오름차순 &#125; @Override public String toString() &#123; return name + \"(\" + age + \")\"; &#125;&#125; Reference http://hochulshin.com/java-comparable-comparator/ http://cwondev.tistory.com/15 https://docs.oracle.com/javase/8/docs/api/java/lang/Comparable.html https://docs.oracle.com/javase/8/docs/api/java/util/Comparator.html","categories":[],"tags":[{"name":"Java","slug":"java","permalink":"https://delf-lee.github.io/tags/java/"}]}]}