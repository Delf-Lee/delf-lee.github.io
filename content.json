{"meta":{"title":"Delf's blog","subtitle":null,"description":null,"author":"Delf","url":"https://delf-lee.github.io"},"pages":[{"title":"","date":"2018-08-28T18:02:18.186Z","updated":"2018-08-28T17:22:09.979Z","comments":true,"path":"index.html","permalink":"https://delf-lee.github.io/index.html","excerpt":"","text":"this is index.md"},{"title":"","date":"2018-09-13T10:55:40.380Z","updated":"2018-09-13T10:55:40.380Z","comments":true,"path":"draft/draft.html","permalink":"https://delf-lee.github.io/draft/draft.html","excerpt":"","text":""},{"title":"","date":"2018-08-26T06:37:25.404Z","updated":"2018-08-26T06:37:25.404Z","comments":true,"path":"about/index.html","permalink":"https://delf-lee.github.io/about/index.html","excerpt":"","text":""}],"posts":[{"title":"제네릭(Generic)이란?","slug":"Java-Generic","date":"2018-09-21T06:13:14.000Z","updated":"2018-09-21T07:40:23.505Z","comments":true,"path":"Java-Generic/","link":"","permalink":"https://delf-lee.github.io/Java-Generic/","excerpt":"","text":"제네릭(Generic)이란? 클래스에서 사용할 타입을 클래스 외부에서 설정하는 것 클래스 내부 데이터 타입을 인스턴스를 생성할 때 확정하는 것 제네릭의 활용제네릭 클래스클래스 생성 시, 내부에서 사용할 필드의 타입을 지정할 수 있습니다. 이를 이용하여 다음과 같이 간단한 List를 구현할 수 있습니다.123456// SimpleList 정의class SimpleList&lt;E&gt; &#123; private &lt;T&gt; elements; public SimpleList(int size) &#123; (E[]) elements = new Object[size]; &#125; ...&#125; 클래스의 인스턴스를 생성할 때 반드시 타입을 명시해주어야 합니다.12345678910// SimpleList 사용SimpleList&lt;String&gt; sList = new SimpleList&lt;&gt;(100);sList.add(\"123\");sList.add(\"456\");System.out.println(sList.get(0) + sList.get(1)); // \"123456\"SimpleList&lt;Integer&gt; iList = new SimpleList&lt;&gt;(100);iList.add(123);iList.add(456);System.out.println(iList.get(0) + iList.get(1)); // 579 전체 코드 보기(Gist) 제네릭 인터페이스12345// 제네릭 인터페이스 정의interface GnrInterface&lt;T1, T2&gt; &#123; T1 doSomething(T2 t); T2 doSomething2(T1 t);&#125; 제네릭 인터페이스를 이용하여 클래스를 구현할 때 타입을 명시해 주어야 합니다.12345678910111213// 제네릭 인터페이스 구현class GnrInterfaceImpl implements GnrInterface&lt;String, Integer&gt; &#123; @Override public String doSomething(Integer t) &#123; return t.toString(); &#125; @Override public Integer doSomething2(String t) &#123; return Integer.parseInt(t); &#125;&#125; 제네릭 메서드제네릭 메서드는 매개 변수 타입 또는 반환 타입으로 타입 파라미터를 갖는 메소드를 말합니다.제네릭 메서드 선언 시, 반드시 반환 타입 앞에 사용되는 타입 파라미터를 명시해 주어여 합니다. 1234public &lt;T&gt; int genericMethod(List&lt;T&gt; list);public &lt;T&gt; List&lt;T&gt; genericMethod(int n);public &lt;T&gt; List&lt;T&gt; genericMethod(List&lt;T&gt; list);public &lt;T1, T2&gt; List&lt;T1&gt; genericMethod(List&lt;T2&gt; list); 제네릭의 장점과 사용하는 이유 타입 안정성(type-safe)을 제공한다. 코드를 작성할 때 사용할 데이터 타입을 분명하게 명시해주어 컴파일 시의 타입 체크(compile-time type check) 가 가능하여 에러를 사전에 방지할 수 있습니다. type-safe: Runtime 시 타입 체크로 인하여 예측 불가능한 문제가 발생하지 않음을 보장하는 것 타입 체크와 형변환을 생략할 수 있으므로(컴퍼일러가 해주기 때문에) 코드가 명확하고 간결해 집니다. 타입의 종류만 바꾸면 되는 로직일 경우, 코드 재활용이 가능합니다. 1. 타입의 안정성 제공컴파일러는 제네릭 코드에 강한 타입 체킹을 적용해서, 코드가 타입 안전을 위반하는 경우 오류를 발생시킵니다.런타임 오류는 프로그램의 안정성을 낮출 뿐러더 컴파일 오류에 비해 비교적 발견이 어렵습니다.1234567// 제네릭 미사용List list = new ArrayList&lt;&gt;();list.add(\"hello\");list.add(\" generic\");list.add(100); // *정수 추가 가능String s1 = (String) list.get(0) + (String) list.get(1); // \"hello generic\"String s2 = (String) list.get(0) + (String) list.get(2); // [runtime error!] 12345// 제네릭 사용List&lt;String&gt; list = new ArrayList&lt;&gt;(); // 타입 명시list.add(\"hello\");list.add(\" generic\");list.add(100); // [compile error!] *정수 추가 불가능 2. 코드의 간결화타입 체크가 명확해지며, 해당 인스턴스를 사용할 때 일일히 형변환을 할 필요가 없습니다.123456// 제네릭 미사용List list = new ArrayList();list.add(\"hello\");list.add(\"generic\");System.out.println((String) list.get(0)); // castingSystem.out.println((String) list.get(1)); // casting 123456// 제네릭 사용List&lt;String&gt; list = new ArrayList&lt;&gt;();list.add(\"hello\");list.add(\"generic\");System.out.println(list.get(0)); // no castSystem.out.println(list.get(1)); // no cast 3. 코드의 재활용제네릭을 사용하는 대표적인 예인 Collection은 타입만 명시해 준다면 같은 클래스를 이용하여 다른 타입을 다루는 인스턴스를 따로 생성할 수 있습니다.12List&lt;String&gt; strList = new ArrayList&lt;&gt;();List&lt;Integer&gt; intList = new ArrayList&lt;&gt;(); 하지만 만약 제네릭이 없다면 다음과 같이 각각의 클래스를 따로 구현해 주어야 할것입니다.12IntegerList intList = new IntegerList();StringList strList = new StringList(); 그리고 그 클래스들의 내부 동작은 유사할 것이고 코드의 중복도 많을 것이라고 예상할 수 있습니다.1234567class IntegerList &#123; ...&#125;class strList &#123; ...&#125; 타입 명명 관례 E - Element K - Key N - Number T - Type V - Value Reference https://github.com/JaeYeopHan/Interview_Question_for_Beginner/tree/master/Java#generic http://devbox.tistory.com/entry/Java-제네릭 https://medium.com/@ohjongsung/자바-제네렉-기본-1267798ffe8e http://devhong.tistory.com/19 http://dohe2014.tistory.com/entry/Why-Use-Generics","categories":[{"name":"Study","slug":"study","permalink":"https://delf-lee.github.io/categories/study/"}],"tags":[{"name":"Java","slug":"java","permalink":"https://delf-lee.github.io/tags/java/"},{"name":"Interview","slug":"interview","permalink":"https://delf-lee.github.io/tags/interview/"}]},{"title":"Cloud Computing를 사용하는 이유","slug":"Why-Cloud-Computing","date":"2018-09-18T05:22:13.000Z","updated":"2018-09-18T14:45:24.489Z","comments":true,"path":"Why-Cloud-Computing/","link":"","permalink":"https://delf-lee.github.io/Why-Cloud-Computing/","excerpt":"","text":"AWS에서 이야기 해주는 Cloud Computing의 장점에 대한 글입니다. 누가 “클라우드 그거 왜 쓰는거야?”라고 물는다면, 이 글이 대답하는데 도움이 될 수 있겠군요! Cloud Computing의 6가지 이점 초기 선투지 비용 없음 운영 비용 절감 탄력적인 운영 및 확장 속도 및 민첩성 비즈니스에만 집중 가능 글로벌 확장 1) 초기 선투자 비용 없음큰 비용과 시간을 소모하는 데이터센터를 구매하고 운용할 필요가 없습니다. 클릭 몇 번으로 수 분 내에 원하는 성능의 서버를 구축할 수 있습니다. On-premis: Cloud와 상반되는 개념으로, 기존의 물리적인 데이터센터(서버)를 운용하는 것. 2) 운영 비용 절감고정된 서버는 최대 트래픽치를 예상하여 구축합니다. 때문에 트래픽이 줄었을 경우에는 자원의 낭비가 발생하고, 수용 범위를 초과한 경우에는 서비스가 느려지거나 중단되는 등의 문제가 발생합니다. On and Off 서버가 중지되고 있는 시간 만큼 자원의 낭비가 발생합니다. Fast Growth 빠른 성장으로 사용자의 유입이 늘어난다면, 적지 않은 비용을 들여 성능 향상을 해주어야 합니다. 미래의 트래픽을 예상하기 힘들고, 비용문제로 잦은 성능 향상은 부담입니다. Variable peaks 유동적인 트래픽 대응하기 어렵습니다. 서버의 성능이 낮다면 많은 사용자를 수용할 수 없고, 성능이 과하게 좋다면 자원의 낭비가 될 수 있습니다. Predictable peaks 트래픽이 많은 일정 시간대(게다가 예상할 수 있는)만을 위한 서버 능력은 자원의 낭비가 될 수 있습니다. 전력, 항온항습, 상면 비용 등의 물리적인 데이터센터를 유지하는 비용과 이를 운영, 관리하는 인력에 소모되는 비용, 소프트웨어의 버전 업에 따른 라이선스 변경과 그 비용, 그리고 향후에 서버를 증설하는 비용까지 On-premise 방식에는 운영하는데 신경 써야 할 요소가 많습니다. 3) 탄력적인 운영 및 확장트래픽의 변동에 유연하게 대응할 수 있습니다. 이는 서버의 안정성이 늘어남에 따라 사용자에게 만족감을 줄 수 있을뿐더러, 서버를 효율적으로 운영하여 비용절감이 가능합니다. 4) 속도 및 민첩성적은 비용으로 손쉽게 애플리케이션을 배포가 가능하기 때문에 서비스 구현 속도가 빨라지고, 더 많은 시도를 할 수 있습니다. On-premises vs Cloud Computing(AWS) 혁신을 위한 시도가 자주 일어나지 않는다 ↔ 혁신을 위한 시도를 많이 할 수 있다 실패의 비용이 높다 ↔ 실패의 비용이 낮다 혁신의 속도가 느려진다 ↔ 많은 혁신이 가능하다 5) 비즈니에스에만 집중 가능서버의 운영부터, 보안, 라이센스, 증설 및 확장 등의 문제에 대해서 자유로워질 수 있습니다. 6) 글로벌 확장전용 데이터센터가 전세계 곳곳에 구축되어 있기 때문에, 따로 데이터 센터를 구축 할 필요 없이 손쉽게 글로벌 서비스가 가능합니다. Reference https://www.youtube.com/watch?v=KBzkeuX32XY https://aws.amazon.com/ko/blogs/korea/tag/webinar/","categories":[{"name":"Study","slug":"study","permalink":"https://delf-lee.github.io/categories/study/"}],"tags":[{"name":"Interview","slug":"interview","permalink":"https://delf-lee.github.io/tags/interview/"},{"name":"Cloud","slug":"cloud","permalink":"https://delf-lee.github.io/tags/cloud/"},{"name":"AWS","slug":"aws","permalink":"https://delf-lee.github.io/tags/aws/"}]},{"title":"객체지향(Object-Oriented)이란?","slug":"Object-Oriented","date":"2018-09-13T10:49:41.000Z","updated":"2018-09-17T23:26:09.272Z","comments":true,"path":"Object-Oriented/","link":"","permalink":"https://delf-lee.github.io/Object-Oriented/","excerpt":"","text":"객체지향(Object-Oriented)이란?객체(Object) 현실세계의 실체 및 개념을 반영하는 상태(Status)와 행위(Behavior)를 정의한 데이터의 집합 객체지향(Object-Oriented) 프로그래밍 각자의 역할을 지닌 객체들끼리 서로 메시지를 주고받으며 동작할 수 있도록 프로그래밍 하는 것 객체지향의 장점(강점)객체를 중심으로 프로그래밍하기 때문에, 사람의 관점에서 프로그램을 이해하고 파악하기 쉽다. 강한 응집력(Strong Cohesion)과 약한 결합력(Weak Coupling)을 가진다. 재사용성, 확장성, 융통성이 높다. 이러한 장점 때문에 디버깅과 유지보수가 용이하고 설계과 분석이 비교적 쉽다. 객체지향의 단점(한계) 객체 간의 정보 교환이 모두 메시지 교환을 통해 일어나므로 실행 시스템에 많은 overhead가 발생하게 된다. 처리속도가 상대적으로 느리다. 하지만 하드웨어의 발전으로 이러한 단점은 어느정도 해소되었다. 객체가 상태를 갖기 때문에 예상치 못한 부작용이 발생할 수 있다. 변수가 존재하고 이 변수를 통해 객체가 예측할 수 없는 상태를 갖게 되어 애플리케이션 내부에서 버그를 발생시킬 수 있다. 이는 함수형 프로그래밍 등장의 패러다임이다. 객체지향적 설계원칙 SOLID SRP(Single Responsibility Principle)단일 책임 원칙 클래스는 단 하나의 책임을 가져야 하며 클래스를 변경하는 이유는 단 하나의 이유이어야 한다. OCP(Open-Closed Principle) : 개방-폐쇄 원칙 확장에는 열려 있어야 하고 변경에는 닫혀 있어야 한다. LSP(Liskov Substitution Principle) : 리스코프 치환 원칙 상위 타입의 객체를 하위 타입의 객체로 치환해도 상위 타입을 사용하는 프로그램은 정상적으로 동작해야 한다. ISP(Interface Segregation Principle) : 인터페이스 분리 원칙 인터페이스는 그 인터페이스를 사용하는 클라이언트를 기준으로 분리해야 한다. DIP(Dependency Inversion Principle) : 의존 역전 원칙 고수준 모듈은 저수준 모듈의 구현에 의존해서는 안된다. 객체지향의 특징추상화 객체에서 공통된 속성이나 기능을 추출하는 것. 중요하지 않은 것(관심 대상이 아닌 것)은 감추거나 무시하고, 중요한 것(관심있는 것)만을 강조하여 추출하는 것. 관점에 따라 추상화의 결과가 달라질 수 있다. 주요 관심사에만 집중함으로써, 프로그램의 복잡도를 관리할 수 있다. 캡슐화관심있는 데이터와 기능을 모아놓고 패킹한 것이다. 객체지향에서는 이를 클래스로 정의하고 외부에서 마음대로 접근할 수 없게하였다. 과거 절차지향 프로그래밍에서는 소스코드가 거대해질수록 데이터가 어디서 어떻게 변화하는지 파악하기 어려웠고 유지보수가 힘들어지는 문제가 발생하였다. 객체지향 프로그래밍에서는 캡슐화를 통해 이란 폐단을 해결하였다. 이렇게 내부의 데이터나 함수를 외부에서 참조하지 못하도록 차단하는 개념을 정보 은닉화(Information Hiding)라고 하며 이것이 바로 캡슐화라는 개념이다. 다형성같은 코드라 하더라도 상황에 따라 다른 방식으로 동작하는 성질. Java에서 다형성을 구현할 수 있는 대표적으로 Overriding과 Overloading이 있다. Overriding임의의 클래스가 다른 클래스를 상속 받거나 인터페이스를 구현했을 때, 상위 클래스 또는 인터페이스에 정의되어 있는 메소드를 재정의 하여 사용하는 것이다. 메소드 호출 시 재정의되어 있지 않다면 상위 클래스의 메소드가 호출된다. (인터페이스는 오버라이딩이 강제된다.) Overloading메소드에 주어진 인자(parameter)에 따라 동작을 다르게 구현할 수 있다. 코드의 중복이 줄어들고, 가독성이 늘어난다. 반환 형(return type)은 관계가 없지만, 인자의 개수, 인자의 타입에 따라 다르게 구현할 수 있다. 상속부모의 형질을 이어받는다는 의미로, 부모 클래스의 속성과 메소드를 그대로 활용할 수 있다. 여기에 더해 새로운 속성과 메소드를 추가할 수 있으며 같은 메소드라 하더라도 오버라이딩(Overriding)을 통하여 재정의하여 다르게 동작하게끔 할 수 있다. 손쉽게 클래스를 재활용할 수 있으며, 부모가 같은 클래스들을 동시에 처리하기 용이하다. 클래스(class)객체를 만들기 위해 상태(field)와 행위(method)를 정의한 틀. 메시지객체지향적으로 구현된 프로그램은 객체들끼리의 메시지를 주고받고 상호작용하며 동작한다. 코드적으로는 임의의 객체에게 인자(parameter)를 전달하여 메소드를 호출하며 반환값(return value)을 받아 처리를 한다. Reference https://github.com/JaeYeopHan/Interview_Question_for_Beginner/tree/master/Development_common_sense#object-oriented-programming https://ko.wikipedia.org/wiki/객체_지향_프로그래밍 http://asfirstalways.tistory.com/177","categories":[{"name":"Study","slug":"study","permalink":"https://delf-lee.github.io/categories/study/"}],"tags":[{"name":"Interview","slug":"interview","permalink":"https://delf-lee.github.io/tags/interview/"},{"name":"OOP","slug":"oop","permalink":"https://delf-lee.github.io/tags/oop/"}]},{"title":"Cloud Computing이란?","slug":"Cloud-Computing","date":"2018-09-11T08:26:12.000Z","updated":"2018-09-16T07:55:27.976Z","comments":true,"path":"Cloud-Computing/","link":"","permalink":"https://delf-lee.github.io/Cloud-Computing/","excerpt":"","text":"개요 클라우드 컴퓨팅이란? 클라우드 컴퓨팅의 등장배경 클라우드 컴퓨팅의 정의 클라우드 컴퓨팅의 특징 클라우드 컴퓨팅 서비스 모델 클라우드 컴퓨팅의 장-단점 클라우드 안정성과 신뢰성 클라우드 도입 1. 클라우드 컴퓨팅이란? 인터넷 ‘너머’에 존재하는 클라우드 사업자의 컴퓨터에서 정보처리를 하는 서비스 특정 기술이 아닌, 사고 방식 또는 개념(모델) 초기 투자나 장기 계약 없이 인터넷을 통해 IT 리소스와 애플리케이션을 원할 때 언제든지(On-demand) 사용할 수 있고 사용한 만큼 요금을 내는 서비스 2. 클라우드 컴퓨팅의 등장배경정보처리 시스템의 흐름 메인프레임 - 1980년대 분산형 클라이언트 서버 모델- 1990년대 사내 인트라넷 → 서버에 집중 - 2000년대 클라우드 컴퓨팅 - 2010년대 전 세계에 분산 배치된 서버 리소스를 필요한 때 필요한 만큼 사용 정보처리 시스템의 흐름 CPU 고속화 가상화 기술 및 분산 처리 기술 빠르고 저렴한 네트워크 거대해진 데이터 센터 (delf: 클라우드 서비스에 종속?) 사용자(기업) - IT 투자 비용 절감 사업자(클라우드 서비스 제공자) - 지속적 매출 3. 클라우드 정의NIST (미국 국립 표준 기술연구소) 정의 - www.ipa.go.jp/files/000025366.pdf 공유 구성이 가능한 컴퓨팅 리소스의 통합을 통해 어디서나 간편하게, 요청에 따라 네트워크를 통해 접근하는 것을 가능하게 하는 모델. 이는 최소한의 이용 절차 또는 서비스 공급자의 상호 작용을 통해, 신속히 할당되어 제공된다. 4. 클라우드 특징 주문형 셀프 서비스 - 사용자 스스로 개별 관리 광범위한 네트워크 접속 리소스 공유 (delf: 가상화 기술) 신속한 확장성 - Scale Up/Down 측정 가능한 서비스 - 종량제 5. 클라우드 서비스 모델 IaaS (Infrastructure as a Service) Paas (Platform as a Service) Saas (Software as a Service) 참고: https://www.ibm.com/cloud/learn/iaas-paas-saas IaaS (Infrastructure as a Service) 사업자는 사용자에게 pay-as-you-go access 제공 Storage, Networking, Servers, … PaaS (Platform as a Service) 사업자는 Cloud-based environment + Infrastructure 제공 사용자는 Application 개발 Java, PHP, Ruby 등의 프로그래밍 언어를 지원하는 애플리케이션 실행 환경이나 데이터베이스 등이 미리 준비되어 있음 개발 및 테스트에 큰 처리 능력이 필요한 경우 자사에서 운영 중인 애플리케이션의 최대 부하를 분산 처리할 때 IoT 데이터를 효율적으로 수집하여 처리하는 플랫폼 Force.com SaaS (Software as a Service) 사업자는 사용자에게 software/application 제공 사용자는 subscrible를 하고 web 또는 API를 통해 access 클라우드 서비스 모델 참고 - from MS MS Azure IaaS란? MS Azure PaaS란? MS Azure SaaS란? Cloud Service ⟺︎ On-premise 회사 내에 자체적으로 데이터 센터를 보유 시스템 구축, 운용까지 직접 수행하는 형태 6-1. 클라우드 컴퓨팅의 장점 경제성: 사용하고자 하는 기간만, 소프트웨어/데이터를 클라우드에서 통합 관리 유연성: 리소스를 필요할 때, 필요한 만큼 확장/축소 가능 가용성: 장애 발생시 계속 사용 가능 빠른 구축 속도 손쉬운 글로벌 서비스(ex. 넷마블의 해외 서바스) 강력한 보안 6-2. 클라우드 컴퓨팅의 단점 생각보다 비싼 비용 점점 커지는 클라우드 의존성 데이터 보관의 불안함 클라우드 이용 모델 Deployment model Private cloud Community cloud Public cloud Hybrid cloud Private cloud 독점적으로 사용되는 클라우드 컴퓨팅 리소스 클라우드 서비스 사용자 또는 사업자의 데이터 센터에 구축한 자사 전용 환경 서비스와 인프라가 개인/기업네트워크에서 유지 관리 됨 Community cloud 공통의 목적을 가진 기업/조직들이 클라우드 시스템을 형성하여 데이터 센터에서 공동 운영하는 형태 Public cloud 클라우드 사업자가 시스템 구축 네트워크를 통해 기업, 개인에게 서비스 제공 기업/개인 방화벽 외부에 구축됨 Hybrid cloud Public, Private, Community 서비스들과 On-premise 시스템을 연계시켜 활용하는 시스템 Private cloud 종류 On-premise private cloud 자사 전용 클라우드 환경 구축, 운용 자체적인 보안정책 → 강력한 보안 환경 부담 Hosted private cloud 클라우드 사업자가 기업 사용자별로 클라우드 환경 제공 기업 전용 클라우드 환경 구축 → 비용 지불 클라우드의 안정성과 신뢰성 클라우드 리스크 장비 고장 리스크 재해, 운영자의 조작 실수 등의 리스크 통신 도청 리스크 중간자 공격 스푸핑 클라우드 사업자의 파산 또는 서비스 중단…클라우드의 보안 거버넌스 기업 경영진이 클라우드를 이용할 때의 위험을 주체적이고 적절하게 관리하기 위한 구조를 구축하고 운용하는 것 보안 등의 리스크를 모두 통제할 수 없다 → 클라우드 서비스의 연속성 리스크 8. 클라우드 도입중소기업의 클라우드 도입 중소기업의 IT 활용 부진의 요인 - 비용, 인재의 부족 클라우드 도입의 장점: 기업의 가치 창출, 성장에 대비 정보 시스템 담당자 비용 절약 시장 환경 변화에 따라 유연하게 시스템을 변화시킬 수 있음 경영진 IT에 투자하는 경영 자원의 최소화 핵심 역량에 경영 자원 집중 가능 대기업의 클라우드 도입 세계 시장 진출시 손쉬운 글로벌화 글로벌하게 전개할 수 있는 효율적인 업무 프로세스 구조 구축 신속한 시스템 도입 및 운영으로부터의 해방","categories":[{"name":"Study","slug":"study","permalink":"https://delf-lee.github.io/categories/study/"}],"tags":[{"name":"Cloud","slug":"cloud","permalink":"https://delf-lee.github.io/tags/cloud/"}]},{"title":"Java의 Comparable과 Comparator","slug":"Comparable-and-Comparator","date":"2018-09-02T13:36:05.000Z","updated":"2018-09-16T07:57:48.384Z","comments":true,"path":"Comparable-and-Comparator/","link":"","permalink":"https://delf-lee.github.io/Comparable-and-Comparator/","excerpt":"","text":"개요 배열 안의 요소 정렬 객체들의 정렬 Comparable interface Comparator interface 예제 1. 배열의 안의 요소 정렬배열 안의 요소는 Java API에서 제공하는 sort()메서드를 이용하면 쉽게 정렬이 가능합니다.12345int[] nums = &#123;4, 1, 3, 2, 5&#125;;Arrays.sort(nums); // 결과: 1, 2, 3, 4, 5String[] strs = &#123;\"D\", \"A\", \"B\", \"E\", \"C\"&#125;;Arrays.sort(strs); // 결과: \"A\", \"B\", \"C\", \"D\", \"E\" 이렇게 정렬이 가능한 이유는 각 요소를 비교할 수 있기 때문입니다. 1보다는 2가 크고, A보다는 B가 크죠. 하지만 아래와 같은 Student 인스턴스가 여러게 있다면, 과연 어떤게 ‘먼저’ 일까요?12345public class Student &#123; public String name; public int age; ...&#125; 2. 객체들의 정렬사용자가 생성한 임의의 객체들을 정렬하기 위해서는 기준이 필요합니다. 즉 객체의 비교가 가능하다면 정렬을 할 수 있게됩니다.어떤게 더 큰지, 어떤게 더 먼저인지 비교가 가능하다면, 그 기준에 따라 정렬이 가능하죠. Comparable interface그 기준을 정의하기 위해서는 해당 class에 Comparable interface를 구현현하는 방법 이 있습니다. CompareTo()메소드를 오버라이드 하여 인스턴스에 대하여 비교 기준을 정의해야 합니다. Comparable은 정렬 수행시 기본적으로 적용되는 정렬 기준이 되는 메서드를 정의해 놓는 인터페이스입니다. 사실, 위에서 Arrays를 이용하여 정렬한 배열안의 요소(객체)를 포함한 대부분의 Java의 기본 자료형들은 Comparable interface를 구현하고 있습니다. 12345678910// Integer classpublic final class Integer extends Number implements Comparable&lt;Integer&gt; &#123; ...&#125;// String classpublic final class String implements java.io.Serializable, Comparable&lt;String&gt;, CharSequence &#123; ...&#125; Comparable interface를 구현하여 Student의 객체들을 나이(age)순으로 정렬하고자 한다면, 다음과 같이 정의할 수 있습니다.123456789public class Student implements Comparable&lt;Student&gt; &#123; public String name; public int age; ... @Override public int compareTo(Student o) &#123; return Integer.compare(this.age, o.age); &#125;&#125; CompareTo()의 반환값이 양수라면 내부 정렬 알고리즘에서 두 요소를 비교할 때 자리를 바꾸고, 0이나 음수라면 바꾸지 않습니다. 1234567891011121314151617Student[] arr = new Student[5];arr[0] = new Student(\"A\", 26);arr[1] = new Student(\"B\", 27);arr[2] = new Student(\"C\", 27);arr[3] = new Student(\"D\", 21);arr[4] = new Student(\"E\", 20);List&lt;Student&gt; students = new ArrayList&lt;&gt;();for (Student student : arr) students.add(student);// 기본 배열에서의 정렬Arrays.sort(arr); // 결과: E(20), D(21), B(27), A(26), C(27)// List Collection에서의 정렬Collections.sort(students); // 결과: E(20), D(21), B(27), A(26), C(27) Comparator interface그렇다면 Student 객체들을 이름 순으로 정렬하고 싶다면? 나이 내림차순으로 정리하고 싶다면 어떡할까요?정렬할 때 마다 Student class의 코드를 수정해야할까요? 이럴 때 쓰이는 것이 바로 Comparator interface입니다. Comparator는 기본 정렬 기준(Comparable을 구현하여 정의한 기준)과는 다른 방식으로 정렬하고 싶을 때 사용하는 인터페이스입니다. 다른 기준의 정렬 조건을 정의하기 위해선 Comparator를 interface를 구현하고 compare()메서드를 작성해야 합니다. 여기서는 간단하게 익명 클래스(Anonymouse class)로 구현하겠습니다.1234567891011121314151617181920212223Student[] arr = new Student[5];arr[0] = new Student(\"A\", 26);arr[1] = new Student(\"B\", 27);arr[2] = new Student(\"C\", 27);arr[3] = new Student(\"D\", 21);arr[4] = new Student(\"E\", 20);List&lt;Student&gt; students = new ArrayList&lt;&gt;();for (Student student : arr) students.add(student);/* Comparator 익명클래스 정의 */Comparator&lt;Student&gt; descNameComparator = new Comparator&lt;Student&gt;() &#123; @Override public int compare(Student s1, Student s2) &#123; return s2.name.compareTo(s1.name); // 이름에 대하여 내림차순 &#125;&#125;;// 기본 배열에서의 정렬Arrays.sort(arr, descNameComparator); // 결과: E(20), D(21), C(27), B(24), A(26)// List Collection에서의 정렬Collections.sort(stdents, descNameComparator); // 결과: E(20), D(21), C(27), B(24), A(26) 이름을 내림차순으로 정렬하기 위하여 String의 비교 값을 출력하였습니다. 이와 같이 Comparator 인터페이스를 구현하면, 임의의 사용자 객체에 대하여 여러 종류의 기준으로 정렬이 가능합니다. 조건문을 통해 compare()메서드의 반환값을 제어해 준다면 정렬 기준을 중복하여 적용할 수 있습니다. 이는 Comparable 인터페이스의 compareTo()메서드도 마찬가지입니다.12345678910// 나이 역순으로 정렬. 나이가 같다면 이름순으로 정렬.Comparator&lt;Student&gt; myComparator = new Comparator&lt;Student&gt;() &#123; @Override public int compare(Student s1, Student s2) &#123; if(s1.age == s2.age) &#123; return s1.name.compareTo(s2.name); &#125; return Integer.compare(s2.age, s1.age); &#125;&#125;; 3. 예제위 설명을 기반으로 한 예제 코드입니다.12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364import java.util.*;public class Main &#123; public static void main(String args[]) &#123; // Student 배열 인스턴스 생성 Student[] arr = new Student[5]; arr[0] = new Student(\"A\", 26); arr[1] = new Student(\"B\", 27); arr[2] = new Student(\"C\", 27); arr[3] = new Student(\"D\", 21); arr[4] = new Student(\"E\", 20); // Student List Collection 인스턴스 생성 List&lt;Student&gt; students = new ArrayList&lt;&gt;(); for (Student student : arr) students.add(student); // 기본 배열에서의 정렬(Comparable interface) Arrays.sort(arr); System.out.println(Arrays.asList(arr)); // E(20), D(21), B(27), A(26), C(27) // List Collection에서의 정렬(Comparable interface) Collections.sort(students); System.out.println(students); // E(20), D(21), B(27), A(26), C(27) System.out.println(); /* Comparator 익명클래스 정의 */ Comparator&lt;Student&gt; descNameComparator = new Comparator&lt;Student&gt;() &#123; @Override public int compare(Student s1, Student s2) &#123; return s2.name.compareTo(s1.name); // 이름에 대하여 내림차순 &#125; &#125;; // 기본 배열에서의 정렬(Comparator interface) Arrays.sort(arr, descNameComparator); System.out.println(Arrays.asList(arr)); // E(20), D(21), C(27), B(27), A(26) // List Collection에서의 정렬(Comparator interface) Collections.sort(students, descNameComparator); System.out.println(students); // E(20), D(21), C(27), B(27), A(26) &#125;&#125;class Student implements Comparable&lt;Student&gt; &#123; public String name; public int age; public Student(String name, int age) &#123; this.name = name; this.age = age; &#125; @Override public int compareTo(Student o) &#123; return Integer.compare(this.age, o.age); // 나이에 대하여 오름차순 &#125; @Override public String toString() &#123; return name + \"(\" + age + \")\"; &#125;&#125; Reference http://hochulshin.com/java-comparable-comparator/ http://cwondev.tistory.com/15 https://docs.oracle.com/javase/8/docs/api/java/lang/Comparable.html https://docs.oracle.com/javase/8/docs/api/java/util/Comparator.html","categories":[],"tags":[{"name":"Java","slug":"java","permalink":"https://delf-lee.github.io/tags/java/"}]}]}