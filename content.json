{"meta":{"title":"Delf's blog","subtitle":null,"description":null,"author":"Delf","url":"https://delf-lee.github.io"},"pages":[{"title":"","date":"2018-08-28T18:02:18.186Z","updated":"2018-08-28T17:22:09.979Z","comments":true,"path":"index.html","permalink":"https://delf-lee.github.io/index.html","excerpt":"","text":"this is index.md"},{"title":"","date":"2018-08-26T06:37:25.404Z","updated":"2018-08-26T06:37:25.404Z","comments":true,"path":"about/index.html","permalink":"https://delf-lee.github.io/about/index.html","excerpt":"","text":""},{"title":"","date":"2018-09-13T10:55:40.380Z","updated":"2018-09-13T10:55:40.380Z","comments":true,"path":"draft/draft.html","permalink":"https://delf-lee.github.io/draft/draft.html","excerpt":"","text":""}],"posts":[{"title":"제네릭(Generic)이란?","slug":"post","date":"2018-09-16T06:13:14.000Z","updated":"2018-09-16T07:53:04.314Z","comments":true,"path":"post/","link":"","permalink":"https://delf-lee.github.io/post/","excerpt":"","text":"","categories":[{"name":"Study","slug":"study","permalink":"https://delf-lee.github.io/categories/study/"}],"tags":[{"name":"Java","slug":"java","permalink":"https://delf-lee.github.io/tags/java/"},{"name":"Interview","slug":"interview","permalink":"https://delf-lee.github.io/tags/interview/"}]},{"title":"객체지향(Object-Oriented)이란?","slug":"what-is-OOP","date":"2018-09-13T10:49:41.000Z","updated":"2018-09-16T07:52:59.715Z","comments":true,"path":"what-is-OOP/","link":"","permalink":"https://delf-lee.github.io/what-is-OOP/","excerpt":"","text":"객체지향(Object-Oriented)이란?객체(Object) 현실세계의 실체 및 개념을 반영하는 상태(Status)와 행위(Behavior)를 정의한 데이터의 집합 객체지향(Object-Oriented) 프로그래밍 각자의 역할을 지닌 객체들끼리 서로 메시지를 주고받으며 동작할 수 있도록 프로그래밍 하는 것 #hehehe 객체지향의 장점(강점)객체를 중심으로 프로그래밍하기 때문에, 사람의 관점에서 프로그램을 이해하고 파악하기 쉽다. 강한 응집력(Strong Cohesion)과 약한 결합력(Weak Coupling)을 가진다. 재사용성, 확장성, 융통성이 높다. 이러한 장점 때문에 디버깅과 유지보수가 용이하고 설계과 분석이 비교적 쉽다. 객체지향의 단점(한계) 객체 간의 정보 교환이 모두 메시지 교환을 통해 일어나므로 실행 시스템에 많은 overhead가 발생하게 된다. 처리속도가 상대적으로 느리다. 하지만 하드웨어의 발전으로 이러한 단점은 어느정도 해소되었다. 객체가 상태를 갖기 때문에 예상치 못한 부작용이 발생할 수 있다. 변수가 존재하고 이 변수를 통해 객체가 예측할 수 없는 상태를 갖게 되어 애플리케이션 내부에서 버그를 발생시킬 수 있다. 이는 함수형 프로그래밍 등장의 패러다임이다. 객체지향적 설계원칙 SOLID SRP(Single Responsibility Principle)단일 책임 원칙 클래스는 단 하나의 책임을 가져야 하며 클래스를 변경하는 이유는 단 하나의 이유이어야 한다. OCP(Open-Closed Principle) : 개방-폐쇄 원칙 확장에는 열려 있어야 하고 변경에는 닫혀 있어야 한다. LSP(Liskov Substitution Principle) : 리스코프 치환 원칙 상위 타입의 객체를 하위 타입의 객체로 치환해도 상위 타입을 사용하는 프로그램은 정상적으로 동작해야 한다. ISP(Interface Segregation Principle) : 인터페이스 분리 원칙 인터페이스는 그 인터페이스를 사용하는 클라이언트를 기준으로 분리해야 한다. DIP(Dependency Inversion Principle) : 의존 역전 원칙 고수준 모듈은 저수준 모듈의 구현에 의존해서는 안된다. 객체지향의 특징추상화 객체에서 공통된 속성이나 기능을 추출하는 것. 중요하지 않은 것(관심 대상이 아닌 것)은 감추거나 무시하고, 중요한 것(관심있는 것)만을 강조하여 추출하는 것. 관점에 따라 추상화의 결과가 달라질 수 있다. 주요 관심사에만 집중함으로써, 프로그램의 복잡도를 관리할 수 있다. 캡슐화관심있는 데이터와 기능을 모아놓고 패킹한 것이다. 객체지향에서는 이를 클래스로 정의하고 외부에서 마음대로 접근할 수 없게하였다. 과거 절차지향 프로그래밍에서는 소스코드가 거대해질수록 데이터가 어디서 어떻게 변화하는지 파악하기 어려웠고 유지보수가 힘들어지는 문제가 발생하였다. 객체지향 프로그래밍에서는 캡슐화를 통해 이란 폐단을 해결하였다. 이렇게 내부의 데이터나 함수를 외부에서 참조하지 못하도록 차단하는 개념을 정보 은닉화(Information Hiding)라고 하며 이것이 바로 캡슐화라는 개념이다. 다형성같은 코드라 하더라도 상황에 따라 다른 방식으로 동작하는 성질. Java에서 다형성을 구현할 수 있는 대표적으로 Overriding과 Overloading이 있다. Overriding임의의 클래스가 다른 클래스를 상속 받거나 인터페이스를 구현했을 때, 상위 클래스 또는 인터페이스에 정의되어 있는 메소드를 재정의 하여 사용하는 것이다. 메소드 호출 시 재정의되어 있지 않다면 상위 클래스의 메소드가 호출된다. (인터페이스는 오버라이딩이 강제된다.) Overloading메소드에 주어진 인자(parameter)에 따라 동작을 다르게 구현할 수 있다. 코드의 중복이 줄어들고, 가독성이 늘어난다. 반환 형(return type)은 관계가 없지만, 인자의 개수, 인자의 타입에 따라 다르게 구현할 수 있다. 상속부모의 형질을 이어받는다는 의미로, 부모 클래스의 속성과 메소드를 그대로 활용할 수 있다. 여기에 더해 새로운 속성과 메소드를 추가할 수 있으며 같은 메소드라 하더라도 오버라이딩(Overriding)을 통하여 재정의하여 다르게 동작하게끔 할 수 있다. 손쉽게 클래스를 재활용할 수 있으며, 부모가 같은 클래스들을 동시에 처리하기 용이하다. 클래스(class)객체를 만들기 위해 상태(field)와 행위(method)를 정의한 틀. 메시지객체지향적으로 구현된 프로그램은 객체들끼리의 메시지를 주고받고 상호작용하며 동작한다. 코드적으로는 임의의 객체에게 인자(parameter)를 전달하여 메소드를 호출하며 반환값(return value)을 받아 처리를 한다. Reference https://github.com/JaeYeopHan/Interview_Question_for_Beginner/tree/master/Development_common_sense#object-oriented-programming https://ko.wikipedia.org/wiki/객체_지향_프로그래밍 http://asfirstalways.tistory.com/177","categories":[{"name":"Study","slug":"study","permalink":"https://delf-lee.github.io/categories/study/"}],"tags":[{"name":"Interview","slug":"interview","permalink":"https://delf-lee.github.io/tags/interview/"},{"name":"OOP","slug":"oop","permalink":"https://delf-lee.github.io/tags/oop/"}]},{"title":"Cloud Computing이란?","slug":"Cloud-Computing","date":"2018-09-11T08:26:12.000Z","updated":"2018-09-16T07:53:02.746Z","comments":true,"path":"Cloud-Computing/","link":"","permalink":"https://delf-lee.github.io/Cloud-Computing/","excerpt":"","text":"개요 클라우드 컴퓨팅이란? 클라우드 컴퓨팅의 등장배경 클라우드 컴퓨팅의 정의 클라우드 컴퓨팅의 특징 클라우드 컴퓨팅 서비스 모델 클라우드 컴퓨팅의 장-단점 클라우드 안정성과 신뢰성 클라우드 도입 1. 클라우드 컴퓨팅이란? 인터넷 ‘너머’에 존재하는 클라우드 사업자의 컴퓨터에서 정보처리를 하는 서비스 특정 기술이 아닌, 사고 방식 또는 개념(모델) 초기 투자나 장기 계약 없이 인터넷을 통해 IT 리소스와 애플리케이션을 원할 때 언제든지(On-demand) 사용할 수 있고 사용한 만큼 요금을 내는 서비스 2. 클라우드 컴퓨팅의 등장배경정보처리 시스템의 흐름 메인프레임 - 1980년대 분산형 클라이언트 서버 모델- 1990년대 사내 인트라넷 → 서버에 집중 - 2000년대 클라우드 컴퓨팅 - 2010년대 전 세계에 분산 배치된 서버 리소스를 필요한 때 필요한 만큼 사용 정보처리 시스템의 흐름 CPU 고속화 가상화 기술 및 분산 처리 기술 빠르고 저렴한 네트워크 거대해진 데이터 센터 (delf: 클라우드 서비스에 종속?) 사용자(기업) - IT 투자 비용 절감 사업자(클라우드 서비스 제공자) - 지속적 매출 3. 클라우드 정의NIST (미국 국립 표준 기술연구소) 정의 - www.ipa.go.jp/files/000025366.pdf 공유 구성이 가능한 컴퓨팅 리소스의 통합을 통해 어디서나 간편하게, 요청에 따라 네트워크를 통해 접근하는 것을 가능하게 하는 모델. 이는 최소한의 이용 절차 또는 서비스 공급자의 상호 작용을 통해, 신속히 할당되어 제공된다. 4. 클라우드 특징 주문형 셀프 서비스 - 사용자 스스로 개별 관리 광범위한 네트워크 접속 리소스 공유 (delf: 가상화 기술) 신속한 확장성 - Scale Up/Down 측정 가능한 서비스 - 종량제 5. 클라우드 서비스 모델 IaaS (Infrastructure as a Service) Paas (Platform as a Service) Saas (Software as a Service) 참고: https://www.ibm.com/cloud/learn/iaas-paas-saas IaaS (Infrastructure as a Service) 사업자는 사용자에게 pay-as-you-go access 제공 Storage, Networking, Servers, … PaaS (Platform as a Service) 사업자는 Cloud-based environment + Infrastructure 제공 사용자는 Application 개발 Java, PHP, Ruby 등의 프로그래밍 언어를 지원하는 애플리케이션 실행 환경이나 데이터베이스 등이 미리 준비되어 있음 개발 및 테스트에 큰 처리 능력이 필요한 경우 자사에서 운영 중인 애플리케이션의 최대 부하를 분산 처리할 때 IoT 데이터를 효율적으로 수집하여 처리하는 플랫폼 Force.com SaaS (Software as a Service) 사업자는 사용자에게 software/application 제공 사용자는 subscrible를 하고 web 또는 API를 통해 access 클라우드 서비스 모델 참고 - from MS MS Azure IaaS란? MS Azure PaaS란? MS Azure SaaS란? Cloud Service ⟺︎ On-premise 회사 내에 자체적으로 데이터 센터를 보유 시스템 구축, 운용까지 직접 수행하는 형태 6-1. 클라우드 컴퓨팅의 장점 경제성: 사용하고자 하는 기간만, 소프트웨어/데이터를 클라우드에서 통합 관리 유연성: 리소스를 필요할 때, 필요한 만큼 확장/축소 가능 가용성: 장애 발생시 계속 사용 가능 빠른 구축 속도 손쉬운 글로벌 서비스(ex. 넷마블의 해외 서바스) 강력한 보안 6-2. 클라우드 컴퓨팅의 단점 생각보다 비싼 비용 점점 커지는 클라우드 의존성 데이터 보관의 불안함 클라우드 이용 모델 Deployment model Private cloud Community cloud Public cloud Hybrid cloud Private cloud 독점적으로 사용되는 클라우드 컴퓨팅 리소스 클라우드 서비스 사용자 또는 사업자의 데이터 센터에 구축한 자사 전용 환경 서비스와 인프라가 개인/기업네트워크에서 유지 관리 됨 Community cloud 공통의 목적을 가진 기업/조직들이 클라우드 시스템을 형성하여 데이터 센터에서 공동 운영하는 형태 Public cloud 클라우드 사업자가 시스템 구축 네트워크를 통해 기업, 개인에게 서비스 제공 기업/개인 방화벽 외부에 구축됨 Hybrid cloud Public, Private, Community 서비스들과 On-premise 시스템을 연계시켜 활용하는 시스템 Private cloud 종류 On-premise private cloud 자사 전용 클라우드 환경 구축, 운용 자체적인 보안정책 → 강력한 보안 환경 부담 Hosted private cloud 클라우드 사업자가 기업 사용자별로 클라우드 환경 제공 기업 전용 클라우드 환경 구축 → 비용 지불 클라우드의 안정성과 신뢰성 클라우드 리스크 장비 고장 리스크 재해, 운영자의 조작 실수 등의 리스크 통신 도청 리스크 중간자 공격 스푸핑 클라우드 사업자의 파산 또는 서비스 중단…클라우드의 보안 거버넌스 기업 경영진이 클라우드를 이용할 때의 위험을 주체적이고 적절하게 관리하기 위한 구조를 구축하고 운용하는 것 보안 등의 리스크를 모두 통제할 수 없다 → 클라우드 서비스의 연속성 리스크 8. 클라우드 도입중소기업의 클라우드 도입 중소기업의 IT 활용 부진의 요인 - 비용, 인재의 부족 클라우드 도입의 장점: 기업의 가치 창출, 성장에 대비 정보 시스템 담당자 비용 절약 시장 환경 변화에 따라 유연하게 시스템을 변화시킬 수 있음 경영진 IT에 투자하는 경영 자원의 최소화 핵심 역량에 경영 자원 집중 가능 대기업의 클라우드 도입 세계 시장 진출시 손쉬운 글로벌화 글로벌하게 전개할 수 있는 효율적인 업무 프로세스 구조 구축 신속한 시스템 도입 및 운영으로부터의 해방","categories":[{"name":"Study","slug":"study","permalink":"https://delf-lee.github.io/categories/study/"}],"tags":[{"name":"Cloud","slug":"cloud","permalink":"https://delf-lee.github.io/tags/cloud/"}]},{"title":"Java의 Comparable과 Comparator","slug":"Comparable-and-Comparator","date":"2018-09-02T13:36:05.000Z","updated":"2018-09-16T07:53:01.683Z","comments":true,"path":"Comparable-and-Comparator/","link":"","permalink":"https://delf-lee.github.io/Comparable-and-Comparator/","excerpt":"","text":"개요 배열 안의 요소 정렬 객체들의 정렬 Comparable interface Comparator interface 예제 1. 배열의 안의 요소 정렬배열 안의 요소는 Java API에서 제공하는 sort()메서드를 이용하면 쉽게 정렬이 가능합니다.12345int[] nums = &#123;4, 1, 3, 2, 5&#125;;Arrays.sort(nums); // 결과: 1, 2, 3, 4, 5String[] strs = &#123;\"D\", \"A\", \"B\", \"E\", \"C\"&#125;;Arrays.sort(strs); // 결과: \"A\", \"B\", \"C\", \"D\", \"E\" 이렇게 정렬이 가능한 이유는 각 요소를 비교할 수 있기 때문입니다. 1보다는 2가 크고, A보다는 B가 크죠. 하지만 아래와 같은 Student 인스턴스가 여러게 있다면, 과연 어떤게 ‘먼저’ 일까요?12345public class Student &#123; public String name; public int age; ...&#125; 2. 객체들의 정렬사용자가 생성한 임의의 객체들을 정렬하기 위해서는 기준이 필요합니다. 즉 객체의 비교가 가능하다면 정렬을 할 수 있게됩니다.어떤게 더 큰지, 어떤게 더 먼저인지 비교가 가능하다면, 그 기준에 따라 정렬이 가능하죠. Comparable interface그 기준을 정의하기 위해서는 해당 class에 Comparable interface를 구현현하는 방법 이 있습니다. CompareTo()메소드를 오버라이드 하여 인스턴스에 대하여 비교 기준을 정의해야 합니다. Comparable은 정렬 수행시 기본적으로 적용되는 정렬 기준이 되는 메서드를 정의해 놓는 인터페이스입니다. 사실, 위에서 Arrays를 이용하여 정렬한 배열안의 요소(객체)를 포함한 대부분의 Java의 기본 자료형들은 Comparable interface를 구현하고 있습니다. 12345678910// Integer classpublic final class Integer extends Number implements Comparable&lt;Integer&gt; &#123; ...&#125;// String classpublic final class String implements java.io.Serializable, Comparable&lt;String&gt;, CharSequence &#123; ...&#125; Comparable interface를 구현하여 Student의 객체들을 나이(age)순으로 정렬하고자 한다면, 다음과 같이 정의할 수 있습니다.123456789public class Student implements Comparable&lt;Student&gt; &#123; public String name; public int age; ... @Override public int compareTo(Student o) &#123; return Integer.compare(this.age, o.age); &#125;&#125; CompareTo()의 반환값이 양수라면 내부 정렬 알고리즘에서 두 요소를 비교할 때 자리를 바꾸고, 0이나 음수라면 바꾸지 않습니다. 1234567891011121314151617Student[] arr = new Student[5];arr[0] = new Student(\"A\", 26);arr[1] = new Student(\"B\", 27);arr[2] = new Student(\"C\", 27);arr[3] = new Student(\"D\", 21);arr[4] = new Student(\"E\", 20);List&lt;Student&gt; students = new ArrayList&lt;&gt;();for (Student student : arr) students.add(student);// 기본 배열에서의 정렬Arrays.sort(arr); // 결과: E(20), D(21), B(27), A(26), C(27)// List Collection에서의 정렬Collections.sort(students); // 결과: E(20), D(21), B(27), A(26), C(27) Comparator interface그렇다면 Student 객체들을 이름 순으로 정렬하고 싶다면? 나이 내림차순으로 정리하고 싶다면 어떡할까요?정렬할 때 마다 Student class의 코드를 수정해야할까요? 이럴 때 쓰이는 것이 바로 Comparator interface입니다. Comparator는 기본 정렬 기준(Comparable을 구현하여 정의한 기준)과는 다른 방식으로 정렬하고 싶을 때 사용하는 인터페이스입니다. 다른 기준의 정렬 조건을 정의하기 위해선 Comparator를 interface를 구현하고 compare()메서드를 작성해야 합니다. 여기서는 간단하게 익명 클래스(Anonymouse class)로 구현하겠습니다.1234567891011121314151617181920212223Student[] arr = new Student[5];arr[0] = new Student(\"A\", 26);arr[1] = new Student(\"B\", 27);arr[2] = new Student(\"C\", 27);arr[3] = new Student(\"D\", 21);arr[4] = new Student(\"E\", 20);List&lt;Student&gt; students = new ArrayList&lt;&gt;();for (Student student : arr) students.add(student);/* Comparator 익명클래스 정의 */Comparator&lt;Student&gt; descNameComparator = new Comparator&lt;Student&gt;() &#123; @Override public int compare(Student s1, Student s2) &#123; return s2.name.compareTo(s1.name); // 이름에 대하여 내림차순 &#125;&#125;;// 기본 배열에서의 정렬Arrays.sort(arr, descNameComparator); // 결과: E(20), D(21), C(27), B(24), A(26)// List Collection에서의 정렬Collections.sort(stdents, descNameComparator); // 결과: E(20), D(21), C(27), B(24), A(26) 이름을 내림차순으로 정렬하기 위하여 String의 비교 값을 출력하였습니다. 이와 같이 Comparator 인터페이스를 구현하면, 임의의 사용자 객체에 대하여 여러 종류의 기준으로 정렬이 가능합니다. 조건문을 통해 compare()메서드의 반환값을 제어해 준다면 정렬 기준을 중복하여 적용할 수 있습니다. 이는 Comparable 인터페이스의 compareTo()메서드도 마찬가지입니다.12345678910// 나이 역순으로 정렬. 나이가 같다면 이름순으로 정렬.Comparator&lt;Student&gt; myComparator = new Comparator&lt;Student&gt;() &#123; @Override public int compare(Student s1, Student s2) &#123; if(s1.age == s2.age) &#123; return s1.name.compareTo(s2.name); &#125; return Integer.compare(s2.age, s1.age); &#125;&#125;; 3. 예제위 설명을 기반으로 한 예제 코드입니다.12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364import java.util.*;public class Main &#123; public static void main(String args[]) &#123; // Student 배열 인스턴스 생성 Student[] arr = new Student[5]; arr[0] = new Student(\"A\", 26); arr[1] = new Student(\"B\", 27); arr[2] = new Student(\"C\", 27); arr[3] = new Student(\"D\", 21); arr[4] = new Student(\"E\", 20); // Student List Collection 인스턴스 생성 List&lt;Student&gt; students = new ArrayList&lt;&gt;(); for (Student student : arr) students.add(student); // 기본 배열에서의 정렬(Comparable interface) Arrays.sort(arr); System.out.println(Arrays.asList(arr)); // E(20), D(21), B(27), A(26), C(27) // List Collection에서의 정렬(Comparable interface) Collections.sort(students); System.out.println(students); // E(20), D(21), B(27), A(26), C(27) System.out.println(); /* Comparator 익명클래스 정의 */ Comparator&lt;Student&gt; descNameComparator = new Comparator&lt;Student&gt;() &#123; @Override public int compare(Student s1, Student s2) &#123; return s2.name.compareTo(s1.name); // 이름에 대하여 내림차순 &#125; &#125;; // 기본 배열에서의 정렬(Comparator interface) Arrays.sort(arr, descNameComparator); System.out.println(Arrays.asList(arr)); // E(20), D(21), C(27), B(27), A(26) // List Collection에서의 정렬(Comparator interface) Collections.sort(students, descNameComparator); System.out.println(students); // E(20), D(21), C(27), B(27), A(26) &#125;&#125;class Student implements Comparable&lt;Student&gt; &#123; public String name; public int age; public Student(String name, int age) &#123; this.name = name; this.age = age; &#125; @Override public int compareTo(Student o) &#123; return Integer.compare(this.age, o.age); // 나이에 대하여 오름차순 &#125; @Override public String toString() &#123; return name + \"(\" + age + \")\"; &#125;&#125; Reference http://hochulshin.com/java-comparable-comparator/ http://cwondev.tistory.com/15 https://docs.oracle.com/javase/8/docs/api/java/lang/Comparable.html https://docs.oracle.com/javase/8/docs/api/java/util/Comparator.html","categories":[],"tags":[{"name":"Java","slug":"java","permalink":"https://delf-lee.github.io/tags/java/"}]}]}