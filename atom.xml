<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Delf&#39;s blog</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://delf-lee.github.io/"/>
  <updated>2018-09-11T08:49:25.491Z</updated>
  <id>https://delf-lee.github.io/</id>
  
  <author>
    <name>Delf</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Cloud Computing이란?</title>
    <link href="https://delf-lee.github.io/2018-09/Cloud-Computing/"/>
    <id>https://delf-lee.github.io/2018-09/Cloud-Computing/</id>
    <published>2018-09-11T08:26:12.000Z</published>
    <updated>2018-09-11T08:49:25.491Z</updated>
    
    <content type="html"><![CDATA[<p><img src="((/post_resources/2018-09-11/1_title.jpg" alt="(출처)http://www.eurekapos.co/todo-esta-en-la-nube/"></p><h1 id="개요"><a href="#개요" class="headerlink" title="개요"></a>개요</h1><ol><li>클라우드 컴퓨팅이란?</li><li>클라우드 컴퓨팅의 등장배경</li><li>클라우드 컴퓨팅의 정의</li><li>클라우드 컴퓨팅의 특징</li><li>클라우드 컴퓨팅 서비스 모델</li><li>클라우드 컴퓨팅의 장-단점</li><li>클라우드 안정성과 신뢰성</li><li>클라우드 도입</li></ol><h1 id="1-클라우드-컴퓨팅이란"><a href="#1-클라우드-컴퓨팅이란" class="headerlink" title="1. 클라우드 컴퓨팅이란?"></a>1. 클라우드 컴퓨팅이란?</h1><ul><li>인터넷 ‘너머’에 존재하는 클라우드 사업자의 컴퓨터에서 정보처리를 하는 서비스</li><li>특정 기술이 아닌, <u>사고 방식</u> 또는 <u>개념(모델)</u><blockquote><ol><li><strong>초기 투자</strong>나 <strong>장기 계약</strong> 없이</li><li><strong>인터넷</strong>을 통해 <strong>IT 리소스</strong>와 <strong>애플리케이션</strong>을</li><li><strong>원할 때 언제든지(On-demand)</strong> 사용할 수 있고</li><li><strong>사용한 만큼</strong> 요금을 내는 서비스</li></ol></blockquote></li></ul><h1 id="2-클라우드-컴퓨팅의-등장배경"><a href="#2-클라우드-컴퓨팅의-등장배경" class="headerlink" title="2. 클라우드 컴퓨팅의 등장배경"></a>2. 클라우드 컴퓨팅의 등장배경</h1><h2 id="정보처리-시스템의-흐름"><a href="#정보처리-시스템의-흐름" class="headerlink" title="정보처리 시스템의 흐름"></a>정보처리 시스템의 흐름</h2><ul><li>메인프레임 - 1980년대</li><li>분산형 클라이언트 서버 모델- 1990년대</li><li>사내 인트라넷 → 서버에 집중 - 2000년대</li><li>클라우드 컴퓨팅 - 2010년대<ul><li>전 세계에 분산 배치된 서버 리소스를 <u>필요한 때</u> <u>필요한 만큼</u> 사용</li></ul></li></ul><h2 id="정보처리-시스템의-흐름-1"><a href="#정보처리-시스템의-흐름-1" class="headerlink" title="정보처리 시스템의 흐름"></a>정보처리 시스템의 흐름</h2><ul><li>CPU 고속화</li><li>가상화 기술 및 분산 처리 기술</li><li>빠르고 저렴한 네트워크</li><li>거대해진 데이터 센터 (delf: 클라우드 서비스에 종속?)</li><li>사용자(기업) - IT 투자 비용 절감</li><li>사업자(클라우드 서비스 제공자) - 지속적 매출</li></ul><h1 id="3-클라우드-정의"><a href="#3-클라우드-정의" class="headerlink" title="3. 클라우드 정의"></a>3. 클라우드 정의</h1><p>NIST (미국 국립 표준 기술연구소) 정의 - <a href="http://www.ipa.go.jp/files/000025366.pdf" target="_blank" rel="noopener">www.ipa.go.jp/files/000025366.pdf</a></p><blockquote><p>공유 구성이 가능한 컴퓨팅 리소스의 통합을 통해 어디서나 간편하게, 요청에 따라 네트워크를 통해 접근하는 것을 가능하게 하는 모델. 이는 최소한의 이용 절차 또는 서비스 공급자의 상호 작용을 통해, 신속히 할당되어 제공된다.</p></blockquote><h1 id="4-클라우드-특징"><a href="#4-클라우드-특징" class="headerlink" title="4. 클라우드 특징"></a>4. 클라우드 특징</h1><ul><li>주문형 셀프 서비스 - 사용자 스스로 개별 관리</li><li>광범위한 네트워크 접속</li><li>리소스 공유 (delf: 가상화 기술)</li><li>신속한 확장성 - Scale Up/Down</li><li>측정 가능한 서비스 - 종량제</li></ul><h1 id="5-클라우드-서비스-모델"><a href="#5-클라우드-서비스-모델" class="headerlink" title="5. 클라우드 서비스 모델"></a>5. 클라우드 서비스 모델</h1><ul><li>IaaS (Infrastructure as a Service)</li><li>Paas (Platform as a Service)</li><li>Saas (Software as a Service)</li></ul><p><img src="/post_resources/2018-09-11/cloudmodel.png" alt=""><br>참고: <a href="https://www.ibm.com/cloud/learn/iaas-paas-saas" target="_blank" rel="noopener">https://www.ibm.com/cloud/learn/iaas-paas-saas</a>   </p><h2 id="IaaS-Infrastructure-as-a-Service"><a href="#IaaS-Infrastructure-as-a-Service" class="headerlink" title="IaaS (Infrastructure as a Service)"></a>IaaS (Infrastructure as a Service)</h2><ul><li>사업자는 사용자에게 pay-as-you-go access 제공</li><li>Storage, Networking, Servers, …</li></ul><p><img src="/post_resources/2018-09-11/infrastructure-as-a-service-iaas.jpg" alt=""></p><h2 id="PaaS-Platform-as-a-Service"><a href="#PaaS-Platform-as-a-Service" class="headerlink" title="PaaS (Platform as a Service)"></a>PaaS (Platform as a Service)</h2><ul><li>사업자는 Cloud-based environment + Infrastructure 제공</li><li>사용자는 Application 개발</li><li>Java, PHP, Ruby 등의 프로그래밍 언어를 지원하는 애플리케이션 실행 환경이나 데이터베이스 등이 미리 준비되어 있음</li><li>개발 및 테스트에 큰 처리 능력이 필요한 경우</li><li>자사에서 운영 중인 애플리케이션의 최대 부하를 분산 처리할 때</li><li>IoT 데이터를 효율적으로 수집하여 처리하는 플랫폼</li><li>Force.com</li></ul><p><img src="/post_resources/2018-09-11/platform-as-a-service-paas.jpg" alt=""></p><h2 id="SaaS-Software-as-a-Service"><a href="#SaaS-Software-as-a-Service" class="headerlink" title="SaaS (Software as a Service)"></a>SaaS (Software as a Service)</h2><ul><li>사업자는 사용자에게 software/application 제공</li><li>사용자는 subscrible를 하고 web 또는 API를 통해 access</li></ul><p><img src="/post_resources/2018-09-11/software-as-a-service-saas.jpg" alt=""></p><h2 id="클라우드-서비스-모델-참고-from-MS"><a href="#클라우드-서비스-모델-참고-from-MS" class="headerlink" title="클라우드 서비스 모델 참고 - from MS"></a>클라우드 서비스 모델 참고 - from MS</h2><ul><li><a href="https://azure.microsoft.com/ko-kr/overview/what-is-iaas/" target="_blank" rel="noopener">MS Azure IaaS란?</a></li><li><a href="https://azure.microsoft.com/ko-kr/overview/what-is-paas/" target="_blank" rel="noopener">MS Azure PaaS란?</a></li><li><a href="https://azure.microsoft.com/ko-kr/overview/what-is-saas/" target="_blank" rel="noopener">MS Azure SaaS란?</a></li></ul><h3 id="Cloud-Service-⟺︎-On-premise"><a href="#Cloud-Service-⟺︎-On-premise" class="headerlink" title="Cloud Service ⟺︎ On-premise"></a>Cloud Service ⟺︎ On-premise</h3><ul><li>회사 내에 자체적으로 데이터 센터를 보유</li><li>시스템 구축, 운용까지 직접 수행하는 형태</li></ul><h1 id="6-1-클라우드-컴퓨팅의-장점"><a href="#6-1-클라우드-컴퓨팅의-장점" class="headerlink" title="6-1. 클라우드 컴퓨팅의 장점"></a>6-1. 클라우드 컴퓨팅의 장점</h1><ul><li><strong>경제성</strong>: 사용하고자 하는 기간만, 소프트웨어/데이터를 클라우드에서 통합 관리</li><li><strong>유연성</strong>: 리소스를 필요할 때, 필요한 만큼 확장/축소 가능</li><li><strong>가용성</strong>: 장애 발생시 계속 사용 가능</li><li>빠른 구축 속도</li><li>손쉬운 글로벌 서비스(ex. 넷마블의 해외 서바스)</li><li>강력한 보안</li></ul><h1 id="6-2-클라우드-컴퓨팅의-단점"><a href="#6-2-클라우드-컴퓨팅의-단점" class="headerlink" title="6-2. 클라우드 컴퓨팅의 단점"></a>6-2. 클라우드 컴퓨팅의 단점</h1><ul><li>생각보다 비싼 비용</li><li>점점 커지는 클라우드 의존성</li><li>데이터 보관의 불안함</li></ul><h1 id="클라우드-이용-모델"><a href="#클라우드-이용-모델" class="headerlink" title="클라우드 이용 모델"></a>클라우드 이용 모델</h1><ul><li>Deployment model</li><li>Private cloud</li><li>Community cloud</li><li>Public cloud</li><li>Hybrid cloud</li></ul><h2 id="Private-cloud"><a href="#Private-cloud" class="headerlink" title="Private cloud"></a>Private cloud</h2><ul><li>독점적으로 사용되는 클라우드 컴퓨팅 리소스</li><li>클라우드 서비스 사용자 또는 사업자의 데이터 센터에 구축한 자사 전용 환경</li><li>서비스와 인프라가 개인/기업네트워크에서 유지 관리 됨</li></ul><h2 id="Community-cloud"><a href="#Community-cloud" class="headerlink" title="Community cloud"></a>Community cloud</h2><ul><li>공통의 목적을 가진 기업/조직들이 클라우드 시스템을 형성하여 데이터 센터에서 <strong>공동 운영</strong>하는 형태</li></ul><h2 id="Public-cloud"><a href="#Public-cloud" class="headerlink" title="Public cloud"></a>Public cloud</h2><ul><li>클라우드 사업자가 시스템 구축</li><li>네트워크를 통해 기업, 개인에게 서비스 제공</li><li>기업/개인 방화벽 외부에 구축됨</li></ul><h2 id="Hybrid-cloud"><a href="#Hybrid-cloud" class="headerlink" title="Hybrid cloud"></a>Hybrid cloud</h2><ul><li>Public, Private, Community 서비스들과 On-premise 시스템을 연계시켜 활용하는 시스템</li></ul><h3 id="Private-cloud-종류"><a href="#Private-cloud-종류" class="headerlink" title="Private cloud 종류"></a>Private cloud 종류</h3><ul><li>On-premise private cloud<ul><li>자사 전용 클라우드 환경 구축, 운용</li><li>자체적인 보안정책 → 강력한 보안 환경 부담</li></ul></li><li>Hosted private cloud<ul><li>클라우드 사업자가 기업 사용자별로 클라우드 환경 제공</li><li>기업 전용 클라우드 환경 구축 → 비용 지불</li></ul></li></ul><p><img src="/post_resources/2018-09-11/kind-of-cloud-model.png" alt=""></p><h1 id="클라우드의-안정성과-신뢰성"><a href="#클라우드의-안정성과-신뢰성" class="headerlink" title="클라우드의 안정성과 신뢰성"></a>클라우드의 안정성과 신뢰성</h1><ul><li>클라우드 리스크</li><li>장비 고장 리스크</li><li>재해, 운영자의 조작 실수 등의 리스크</li><li>통신 도청 리스크</li><li>중간자 공격</li><li>스푸핑</li><li>클라우드 사업자의 파산 또는 서비스 중단<br>…<h2 id="클라우드의-보안-거버넌스"><a href="#클라우드의-보안-거버넌스" class="headerlink" title="클라우드의 보안 거버넌스"></a>클라우드의 보안 거버넌스</h2></li><li>기업 경영진이 클라우드를 이용할 때의 위험을 주체적이고 적절하게 관리하기 위한 구조를 구축하고 운용하는 것</li><li>보안 등의 리스크를 모두 통제할 수 없다 → 클라우드 서비스의 연속성 리스크</li></ul><h1 id="8-클라우드-도입"><a href="#8-클라우드-도입" class="headerlink" title="8. 클라우드 도입"></a>8. 클라우드 도입</h1><h2 id="중소기업의-클라우드-도입"><a href="#중소기업의-클라우드-도입" class="headerlink" title="중소기업의 클라우드 도입"></a>중소기업의 클라우드 도입</h2><ul><li>중소기업의 IT 활용 부진의 요인 - 비용, 인재의 부족</li><li>클라우드 도입의 장점: 기업의 가치 창출, 성장에 대비</li><li>정보 시스템 담당자<ul><li>비용 절약</li><li>시장 환경 변화에 따라 유연하게 시스템을 변화시킬 수 있음</li></ul></li><li>경영진<ul><li>IT에 투자하는 경영 자원의 최소화</li><li>핵심 역량에 경영 자원 집중 가능</li></ul></li></ul><h2 id="대기업의-클라우드-도입"><a href="#대기업의-클라우드-도입" class="headerlink" title="대기업의 클라우드 도입"></a>대기업의 클라우드 도입</h2><ul><li>세계 시장 진출시 손쉬운 글로벌화</li><li>글로벌하게 전개할 수 있는 효율적인 업무 프로세스 구조 구축</li><li>신속한 시스템 도입 및 운영으로부터의 해방</li></ul>]]></content>
    
    <summary type="html">
    
      클라우드 컴퓨팅에 대한 소개
    
    </summary>
    
      <category term="Study" scheme="https://delf-lee.github.io/categories/study/"/>
    
    
      <category term="Cloud" scheme="https://delf-lee.github.io/tags/cloud/"/>
    
  </entry>
  
  <entry>
    <title>Java의 Comparable과 Comparator</title>
    <link href="https://delf-lee.github.io/2018-09/Comparable-and-Comparator/"/>
    <id>https://delf-lee.github.io/2018-09/Comparable-and-Comparator/</id>
    <published>2018-09-02T13:36:05.000Z</published>
    <updated>2018-09-11T08:43:09.268Z</updated>
    
    <content type="html"><![CDATA[<hr><!-- ![](/post_resources/2018-09-08/1_title.png){: width="100"){: .center} --><p><img src="/post_resources/2018-09-08/1_title.png" width="400"></p><h1 id="개요"><a href="#개요" class="headerlink" title="개요"></a>개요</h1><ol><li>배열 안의 요소 정렬</li><li>객체들의 정렬<ul><li><code>Comparable</code> interface</li><li><code>Comparator</code> interface</li></ul></li><li>예제</li></ol><h1 id="1-배열의-안의-요소-정렬"><a href="#1-배열의-안의-요소-정렬" class="headerlink" title="1. 배열의 안의 요소 정렬"></a>1. 배열의 안의 요소 정렬</h1><p>배열 안의 요소는 Java API에서 제공하는 <code>sort()</code>메서드를 이용하면 쉽게 정렬이 가능합니다.<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span>[] nums = &#123;<span class="number">4</span>, <span class="number">1</span>, <span class="number">3</span>, <span class="number">2</span>, <span class="number">5</span>&#125;;</span><br><span class="line">Arrays.sort(nums); <span class="comment">// 결과: 1, 2, 3, 4, 5</span></span><br><span class="line"></span><br><span class="line">String[] strs  = &#123;<span class="string">"D"</span>, <span class="string">"A"</span>, <span class="string">"B"</span>, <span class="string">"E"</span>, <span class="string">"C"</span>&#125;;</span><br><span class="line">Arrays.sort(strs); <span class="comment">// 결과: "A", "B", "C", "D", "E"</span></span><br></pre></td></tr></table></figure></p><p>이렇게 정렬이 가능한 이유는 각 요소를 <strong>비교</strong>할 수 있기 때문입니다. 1보다는 2가 크고, A보다는 B가 크죠.</p><p>하지만 아래와 같은 <code>Student</code> 인스턴스가 여러게 있다면, 과연 어떤게 <em>‘먼저’</em> 일까요?<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Student</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> String name;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span> age;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h1 id="2-객체들의-정렬"><a href="#2-객체들의-정렬" class="headerlink" title="2. 객체들의 정렬"></a>2. 객체들의 정렬</h1><p>사용자가 생성한 임의의 객체들을 정렬하기 위해서는 <strong>기준</strong>이 필요합니다. 즉 객체의 <strong>비교</strong>가 가능하다면 정렬을 할 수 있게됩니다.<br>어떤게 더 큰지, 어떤게 더 먼저인지 비교가 가능하다면, 그 기준에 따라 정렬이 가능하죠.</p><h2 id="Comparable-interface"><a href="#Comparable-interface" class="headerlink" title="Comparable interface"></a><code>Comparable</code> interface</h2><p>그 <strong>기준</strong>을 정의하기 위해서는 해당 class에 <code>Comparable</code> interface를 구현현하는 방법 이 있습니다. <code>CompareTo()</code>메소드를 오버라이드 하여 인스턴스에 대하여 비교 기준을 정의해야 합니다.</p><blockquote><p><u><code>Comparable</code>은 정렬 수행시 기본적으로 적용되는 정렬 기준이 되는 메서드를 정의해 놓는 인터페이스</u>입니다. </p></blockquote><p>사실, 위에서 <code>Arrays</code>를 이용하여 정렬한 배열안의 요소(객체)를 포함한 대부분의 Java의 기본 자료형들은 <code>Comparable</code> interface를 구현하고 있습니다.  </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Integer class</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">Integer</span> <span class="keyword">extends</span> <span class="title">Number</span> <span class="keyword">implements</span> <span class="title">Comparable</span>&lt;<span class="title">Integer</span>&gt; </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// String class</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">String</span></span></span><br><span class="line"><span class="class">    <span class="keyword">implements</span> <span class="title">java</span>.<span class="title">io</span>.<span class="title">Serializable</span>, <span class="title">Comparable</span>&lt;<span class="title">String</span>&gt;, <span class="title">CharSequence</span> </span>&#123;</span><br><span class="line">        ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>Comparable</code> interface를 구현하여 <code>Student</code>의 객체들을 나이(age)순으로 정렬하고자 한다면, 다음과 같이 정의할 수 있습니다.<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Student</span> <span class="keyword">implements</span> <span class="title">Comparable</span>&lt;<span class="title">Student</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> String name;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span> age;</span><br><span class="line">    ...</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compareTo</span><span class="params">(Student o)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> Integer.compare(<span class="keyword">this</span>.age, o.age);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><code>CompareTo()</code>의 반환값이 양수라면 내부 정렬 알고리즘에서 두 요소를 비교할 때 자리를 바꾸고, 0이나 음수라면 바꾸지 않습니다.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">Student[] arr = <span class="keyword">new</span> Student[<span class="number">5</span>];</span><br><span class="line">arr[<span class="number">0</span>] = <span class="keyword">new</span> Student(<span class="string">"A"</span>, <span class="number">26</span>);</span><br><span class="line">arr[<span class="number">1</span>] = <span class="keyword">new</span> Student(<span class="string">"B"</span>, <span class="number">27</span>);</span><br><span class="line">arr[<span class="number">2</span>] = <span class="keyword">new</span> Student(<span class="string">"C"</span>, <span class="number">27</span>);</span><br><span class="line">arr[<span class="number">3</span>] = <span class="keyword">new</span> Student(<span class="string">"D"</span>, <span class="number">21</span>);</span><br><span class="line">arr[<span class="number">4</span>] = <span class="keyword">new</span> Student(<span class="string">"E"</span>, <span class="number">20</span>);</span><br><span class="line"></span><br><span class="line">List&lt;Student&gt; students = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"><span class="keyword">for</span> (Student student : arr) </span><br><span class="line">    students.add(student);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 기본 배열에서의 정렬</span></span><br><span class="line">Arrays.sort(arr); <span class="comment">// 결과: E(20), D(21), B(27), A(26), C(27)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// List Collection에서의 정렬</span></span><br><span class="line">Collections.sort(students); <span class="comment">// 결과: E(20), D(21), B(27), A(26), C(27)</span></span><br></pre></td></tr></table></figure><h2 id="Comparator-interface"><a href="#Comparator-interface" class="headerlink" title="Comparator interface"></a><code>Comparator</code> interface</h2><p>그렇다면 <code>Student</code> 객체들을 <em>이름 순</em>으로 정렬하고 싶다면? <em>나이 내림차순</em>으로 정리하고 싶다면 어떡할까요?<br>정렬할 때 마다 <code>Student</code> class의 코드를 수정해야할까요?</p><p>이럴 때 쓰이는 것이 바로 <code>Comparator</code> interface입니다.  </p><blockquote><p><code>Comparator</code>는 <u>기본 정렬 기준(<code>Comparable</code>을 구현하여 정의한 기준)과는 다른 방식으로 정렬하고 싶을 때 사용하는 인터페이스</u>입니다. </p></blockquote><p>다른 기준의 정렬 조건을 정의하기 위해선 <code>Comparator</code>를 interface를 구현하고 <code>compare()</code>메서드를 작성해야 합니다. 여기서는 간단하게 익명 클래스(Anonymouse class)로 구현하겠습니다.<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">Student[] arr = <span class="keyword">new</span> Student[<span class="number">5</span>];</span><br><span class="line">arr[<span class="number">0</span>] = <span class="keyword">new</span> Student(<span class="string">"A"</span>, <span class="number">26</span>);</span><br><span class="line">arr[<span class="number">1</span>] = <span class="keyword">new</span> Student(<span class="string">"B"</span>, <span class="number">27</span>);</span><br><span class="line">arr[<span class="number">2</span>] = <span class="keyword">new</span> Student(<span class="string">"C"</span>, <span class="number">27</span>);</span><br><span class="line">arr[<span class="number">3</span>] = <span class="keyword">new</span> Student(<span class="string">"D"</span>, <span class="number">21</span>);</span><br><span class="line">arr[<span class="number">4</span>] = <span class="keyword">new</span> Student(<span class="string">"E"</span>, <span class="number">20</span>);</span><br><span class="line"></span><br><span class="line">List&lt;Student&gt; students = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"><span class="keyword">for</span> (Student student : arr) </span><br><span class="line">    students.add(student);</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Comparator 익명클래스 정의 */</span></span><br><span class="line">Comparator&lt;Student&gt; descNameComparator = <span class="keyword">new</span> Comparator&lt;Student&gt;() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compare</span><span class="params">(Student s1, Student s2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> s2.name.compareTo(s1.name); <span class="comment">// 이름에 대하여 내림차순</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// 기본 배열에서의 정렬</span></span><br><span class="line">Arrays.sort(arr, descNameComparator); <span class="comment">// 결과: E(20), D(21), C(27), B(24), A(26)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// List Collection에서의 정렬</span></span><br><span class="line">Collections.sort(stdents, descNameComparator); <span class="comment">// 결과: E(20), D(21), C(27), B(24), A(26)</span></span><br></pre></td></tr></table></figure></p><p>이름을 내림차순으로 정렬하기 위하여 String의 비교 값을 출력하였습니다. 이와 같이 <code>Comparator</code> 인터페이스를 구현하면, 임의의 사용자 객체에 대하여 여러 종류의 기준으로 정렬이 가능합니다.</p><p>조건문을 통해 <code>compare()</code>메서드의 반환값을 제어해 준다면 정렬 기준을 중복하여 적용할 수 있습니다. 이는 <code>Comparable</code> 인터페이스의 <code>compareTo()</code>메서드도 마찬가지입니다.<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 나이 역순으로 정렬. 나이가 같다면 이름순으로 정렬.</span></span><br><span class="line">Comparator&lt;Student&gt; myComparator = <span class="keyword">new</span> Comparator&lt;Student&gt;() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compare</span><span class="params">(Student s1, Student s2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(s1.age == s2.age) &#123;</span><br><span class="line">            <span class="keyword">return</span> s1.name.compareTo(s2.name);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> Integer.compare(s2.age, s1.age);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><h1 id="3-예제"><a href="#3-예제" class="headerlink" title="3. 예제"></a>3. 예제</h1><p>위 설명을 기반으로 한 예제 코드입니다.<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String args[])</span> </span>&#123;</span><br><span class="line">        <span class="comment">// Student 배열 인스턴스 생성</span></span><br><span class="line">        Student[] arr = <span class="keyword">new</span> Student[<span class="number">5</span>];</span><br><span class="line">        arr[<span class="number">0</span>] = <span class="keyword">new</span> Student(<span class="string">"A"</span>, <span class="number">26</span>);</span><br><span class="line">        arr[<span class="number">1</span>] = <span class="keyword">new</span> Student(<span class="string">"B"</span>, <span class="number">27</span>);</span><br><span class="line">        arr[<span class="number">2</span>] = <span class="keyword">new</span> Student(<span class="string">"C"</span>, <span class="number">27</span>);</span><br><span class="line">        arr[<span class="number">3</span>] = <span class="keyword">new</span> Student(<span class="string">"D"</span>, <span class="number">21</span>);</span><br><span class="line">        arr[<span class="number">4</span>] = <span class="keyword">new</span> Student(<span class="string">"E"</span>, <span class="number">20</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Student List Collection 인스턴스 생성</span></span><br><span class="line">        List&lt;Student&gt; students = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (Student student : arr)</span><br><span class="line">            students.add(student);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 기본 배열에서의 정렬(Comparable interface)</span></span><br><span class="line">        Arrays.sort(arr);</span><br><span class="line">        System.out.println(Arrays.asList(arr)); <span class="comment">// E(20), D(21), B(27), A(26), C(27)</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// List Collection에서의 정렬(Comparable interface)</span></span><br><span class="line">        Collections.sort(students);</span><br><span class="line">        System.out.println(students); <span class="comment">// E(20), D(21), B(27), A(26), C(27)</span></span><br><span class="line"></span><br><span class="line">        System.out.println();</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* Comparator 익명클래스 정의 */</span></span><br><span class="line">        Comparator&lt;Student&gt; descNameComparator = <span class="keyword">new</span> Comparator&lt;Student&gt;() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compare</span><span class="params">(Student s1, Student s2)</span> </span>&#123;</span><br><span class="line">                <span class="keyword">return</span> s2.name.compareTo(s1.name); <span class="comment">// 이름에 대하여 내림차순</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 기본 배열에서의 정렬(Comparator interface)</span></span><br><span class="line">        Arrays.sort(arr, descNameComparator);</span><br><span class="line">        System.out.println(Arrays.asList(arr)); <span class="comment">// E(20), D(21), C(27), B(27), A(26)</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// List Collection에서의 정렬(Comparator interface)</span></span><br><span class="line">        Collections.sort(students, descNameComparator);</span><br><span class="line">        System.out.println(students); <span class="comment">// E(20), D(21), C(27), B(27), A(26)</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Student</span> <span class="keyword">implements</span> <span class="title">Comparable</span>&lt;<span class="title">Student</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> String name;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span> age;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Student</span><span class="params">(String name, <span class="keyword">int</span> age)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">        <span class="keyword">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compareTo</span><span class="params">(Student o)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> Integer.compare(<span class="keyword">this</span>.age, o.age); <span class="comment">// 나이에 대하여 오름차순</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> name + <span class="string">"("</span> + age + <span class="string">")"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h3><ul><li><a href="http://hochulshin.com/java-comparable-comparator/" target="_blank" rel="noopener">http://hochulshin.com/java-comparable-comparator/</a></li><li><a href="http://cwondev.tistory.com/15" target="_blank" rel="noopener">http://cwondev.tistory.com/15</a></li><li><a href="https://docs.oracle.com/javase/8/docs/api/java/lang/Comparable.html" target="_blank" rel="noopener">https://docs.oracle.com/javase/8/docs/api/java/lang/Comparable.html</a></li><li><a href="https://docs.oracle.com/javase/8/docs/api/java/util/Comparator.html" target="_blank" rel="noopener">https://docs.oracle.com/javase/8/docs/api/java/util/Comparator.html</a></li></ul>]]></content>
    
    <summary type="html">
    
      Java에서 임의의 객체를 담은 배열을 정렬하기 위해 Comparable과 Comparator의 사용 방법에 대해서 알아봅니다.
    
    </summary>
    
    
      <category term="Java" scheme="https://delf-lee.github.io/tags/java/"/>
    
  </entry>
  
</feed>
