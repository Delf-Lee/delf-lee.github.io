<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Delf&#39;s blog</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://delf-lee.github.io/"/>
  <updated>2018-09-16T06:40:42.068Z</updated>
  <id>https://delf-lee.github.io/</id>
  
  <author>
    <name>Delf</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>제네릭(Generic)이란?</title>
    <link href="https://delf-lee.github.io/post/"/>
    <id>https://delf-lee.github.io/post/</id>
    <published>2018-09-16T06:13:14.000Z</published>
    <updated>2018-09-16T06:40:42.068Z</updated>
    
    <summary type="html">
    
      제네릭Generic)의 사용방법과 예제
    
    </summary>
    
      <category term="Study" scheme="https://delf-lee.github.io/categories/study/"/>
    
    
      <category term="Java" scheme="https://delf-lee.github.io/tags/java/"/>
    
      <category term="Interview" scheme="https://delf-lee.github.io/tags/interview/"/>
    
  </entry>
  
  <entry>
    <title>객체지향(Object-Oriented)이란?</title>
    <link href="https://delf-lee.github.io/what-is-OOP/"/>
    <id>https://delf-lee.github.io/what-is-OOP/</id>
    <published>2018-09-13T10:49:41.000Z</published>
    <updated>2018-09-16T06:31:54.589Z</updated>
    
    <content type="html"><![CDATA[<p><img src="/post_resources/2018-09-13/title_OOP.jpg" alt=""></p><h1 id="객체지향-Object-Oriented-이란"><a href="#객체지향-Object-Oriented-이란" class="headerlink" title="객체지향(Object-Oriented)이란?"></a>객체지향(Object-Oriented)이란?</h1><h2 id="객체-Object"><a href="#객체-Object" class="headerlink" title="객체(Object)"></a>객체(Object)</h2><blockquote><p>현실세계의 실체 및 개념을 반영하는 상태(Status)와 행위(Behavior)를 정의한 데이터의 집합</p></blockquote><h2 id="객체지향-Object-Oriented-프로그래밍"><a href="#객체지향-Object-Oriented-프로그래밍" class="headerlink" title="객체지향(Object-Oriented) 프로그래밍"></a>객체지향(Object-Oriented) 프로그래밍</h2><blockquote><p>각자의 역할을 지닌 <em>객체</em>들끼리 서로 메시지를 주고받으며 동작할 수 있도록 프로그래밍 하는 것</p></blockquote><p>#hehehe 객체지향의 장점(강점)<br>객체를 중심으로 프로그래밍하기 때문에,</p><ul><li>사람의 관점에서 프로그램을 이해하고 파악하기 쉽다.</li><li>강한 응집력(Strong Cohesion)과 약한 결합력(Weak Coupling)을 가진다.</li><li><em>재사용성</em>, <em>확장성</em>, <em>융통성</em>이 높다.</li></ul><p>이러한 장점 때문에 디버깅과 유지보수가 용이하고 설계과 분석이 비교적 쉽다.</p><h1 id="객체지향의-단점-한계"><a href="#객체지향의-단점-한계" class="headerlink" title="객체지향의 단점(한계)"></a>객체지향의 단점(한계)</h1><ul><li>객체 간의 정보 교환이 모두 메시지 교환을 통해 일어나므로 실행 시스템에 많은 overhead가 발생하게 된다.<ul><li>처리속도가 상대적으로 느리다.</li><li>하지만 하드웨어의 발전으로 이러한 단점은 어느정도 해소되었다. </li></ul></li><li>객체가 <em>상태를 갖기 때문에</em> 예상치 못한 부작용이 발생할 수 있다. 변수가 존재하고 이 변수를 통해 객체가 예측할 수 없는 상태를 갖게 되어 애플리케이션 내부에서 버그를 발생시킬 수 있다.<ul><li>이는 함수형 프로그래밍 등장의 패러다임이다.</li></ul></li></ul><h1 id="객체지향적-설계원칙-SOLID"><a href="#객체지향적-설계원칙-SOLID" class="headerlink" title="객체지향적 설계원칙 SOLID"></a>객체지향적 설계원칙 SOLID</h1><ul><li>SRP(Single Responsibility Principle)단일 책임 원칙<ul><li>클래스는 단 하나의 책임을 가져야 하며 클래스를 변경하는 이유는 단 하나의 이유이어야 한다.</li></ul></li><li>OCP(Open-Closed Principle) : 개방-폐쇄 원칙<ul><li>확장에는 열려 있어야 하고 변경에는 닫혀 있어야 한다.</li></ul></li><li>LSP(Liskov Substitution Principle) : 리스코프 치환 원칙<ul><li>상위 타입의 객체를 하위 타입의 객체로 치환해도 상위 타입을 사용하는 프로그램은 정상적으로 동작해야 한다.</li></ul></li><li>ISP(Interface Segregation Principle) : 인터페이스 분리 원칙<ul><li>인터페이스는 그 인터페이스를 사용하는 클라이언트를 기준으로 분리해야 한다.</li></ul></li><li>DIP(Dependency Inversion Principle) : 의존 역전 원칙<ul><li>고수준 모듈은 저수준 모듈의 구현에 의존해서는 안된다.</li></ul></li></ul><h1 id="객체지향의-특징"><a href="#객체지향의-특징" class="headerlink" title="객체지향의 특징"></a>객체지향의 특징</h1><h2 id="추상화"><a href="#추상화" class="headerlink" title="추상화"></a>추상화</h2><ul><li>객체에서 공통된 속성이나 기능을 추출하는 것.</li><li>중요하지 않은 것(관심 대상이 아닌 것)은 감추거나 무시하고, 중요한 것(관심있는 것)만을 강조하여 추출하는 것.</li><li>관점에 따라 추상화의 결과가 달라질 수 있다.</li><li>주요 관심사에만 집중함으로써, 프로그램의 복잡도를 관리할 수 있다.</li></ul><h2 id="캡슐화"><a href="#캡슐화" class="headerlink" title="캡슐화"></a>캡슐화</h2><p>관심있는 데이터와 기능을 모아놓고 패킹한 것이다. 객체지향에서는 이를 클래스로 정의하고 외부에서 마음대로 접근할 수 없게하였다. 과거 절차지향 프로그래밍에서는 소스코드가 거대해질수록 데이터가 어디서 어떻게 변화하는지 파악하기 어려웠고 유지보수가 힘들어지는 문제가 발생하였다. 객체지향 프로그래밍에서는 캡슐화를 통해 이란 폐단을 해결하였다. 이렇게 내부의 데이터나 함수를 외부에서 참조하지 못하도록 차단하는 개념을 정보 은닉화(Information Hiding)라고 하며 이것이 바로 캡슐화라는 개념이다.</p><h2 id="다형성"><a href="#다형성" class="headerlink" title="다형성"></a>다형성</h2><p>같은 코드라 하더라도 상황에 따라 다른 방식으로 동작하는 성질. Java에서 다형성을 구현할 수 있는 대표적으로 Overriding과 Overloading이 있다.</p><h3 id="Overriding"><a href="#Overriding" class="headerlink" title="Overriding"></a>Overriding</h3><p>임의의 클래스가 다른 클래스를 상속 받거나 인터페이스를 구현했을 때, 상위 클래스 또는 인터페이스에 정의되어 있는 메소드를 재정의 하여 사용하는 것이다. 메소드 호출 시 재정의되어 있지 않다면 상위 클래스의 메소드가 호출된다. (인터페이스는 오버라이딩이 강제된다.)</p><h3 id="Overloading"><a href="#Overloading" class="headerlink" title="Overloading"></a>Overloading</h3><p>메소드에 주어진 인자(parameter)에 따라 동작을 다르게 구현할 수 있다. 코드의 중복이 줄어들고, 가독성이 늘어난다. 반환 형(return type)은 관계가 없지만, 인자의 개수, 인자의 타입에 따라 다르게 구현할 수 있다.</p><h2 id="상속"><a href="#상속" class="headerlink" title="상속"></a>상속</h2><p>부모의 형질을 이어받는다는 의미로, 부모 클래스의 속성과 메소드를 그대로 활용할 수 있다. 여기에 더해 새로운 속성과 메소드를 추가할 수 있으며 같은 메소드라 하더라도 오버라이딩(Overriding)을 통하여 재정의하여 다르게 동작하게끔 할 수 있다. 손쉽게 클래스를 재활용할 수 있으며, 부모가 같은 클래스들을 동시에 처리하기 용이하다.</p><h2 id="클래스-class"><a href="#클래스-class" class="headerlink" title="클래스(class)"></a>클래스(class)</h2><p>객체를 만들기 위해 상태(field)와 행위(method)를 정의한 틀.</p><h2 id="메시지"><a href="#메시지" class="headerlink" title="메시지"></a>메시지</h2><p>객체지향적으로 구현된 프로그램은 객체들끼리의 메시지를 주고받고 상호작용하며 동작한다. 코드적으로는 임의의 객체에게 인자(parameter)를 전달하여 메소드를 호출하며 반환값(return value)을 받아 처리를 한다.</p><h3 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h3><ul><li><a href="https://github.com/JaeYeopHan/Interview_Question_for_Beginner/tree/master/Development_common_sense#object-oriented-programming" target="_blank" rel="noopener">https://github.com/JaeYeopHan/Interview_Question_for_Beginner/tree/master/Development_common_sense#object-oriented-programming</a></li><li><a href="https://ko.wikipedia.org/wiki/객체_지향_프로그래밍" target="_blank" rel="noopener">https://ko.wikipedia.org/wiki/객체_지향_프로그래밍</a></li><li><a href="http://asfirstalways.tistory.com/177" target="_blank" rel="noopener">http://asfirstalways.tistory.com/177</a></li></ul>]]></content>
    
    <summary type="html">
    
      객체지향에 대한 전반적인 개념
    
    </summary>
    
      <category term="Study" scheme="https://delf-lee.github.io/categories/study/"/>
    
    
      <category term="Interview" scheme="https://delf-lee.github.io/tags/interview/"/>
    
      <category term="OOP" scheme="https://delf-lee.github.io/tags/oop/"/>
    
  </entry>
  
  <entry>
    <title>Cloud Computing이란?</title>
    <link href="https://delf-lee.github.io/Cloud-Computing/"/>
    <id>https://delf-lee.github.io/Cloud-Computing/</id>
    <published>2018-09-11T08:26:12.000Z</published>
    <updated>2018-09-13T14:12:03.557Z</updated>
    
    <content type="html"><![CDATA[<p><img src="/post_resources/2018-09-11/1_title.jpg" alt=""></p><h1 id="개요"><a href="#개요" class="headerlink" title="개요"></a>개요</h1><ol><li>클라우드 컴퓨팅이란?</li><li>클라우드 컴퓨팅의 등장배경</li><li>클라우드 컴퓨팅의 정의</li><li>클라우드 컴퓨팅의 특징</li><li>클라우드 컴퓨팅 서비스 모델</li><li>클라우드 컴퓨팅의 장-단점</li><li>클라우드 안정성과 신뢰성</li><li>클라우드 도입</li></ol><h1 id="1-클라우드-컴퓨팅이란"><a href="#1-클라우드-컴퓨팅이란" class="headerlink" title="1. 클라우드 컴퓨팅이란?"></a>1. 클라우드 컴퓨팅이란?</h1><ul><li>인터넷 ‘너머’에 존재하는 클라우드 사업자의 컴퓨터에서 정보처리를 하는 서비스</li><li>특정 기술이 아닌, <u>사고 방식</u> 또는 <u>개념(모델)</u><blockquote><ol><li><strong>초기 투자</strong>나 <strong>장기 계약</strong> 없이</li><li><strong>인터넷</strong>을 통해 <strong>IT 리소스</strong>와 <strong>애플리케이션</strong>을</li><li><strong>원할 때 언제든지(On-demand)</strong> 사용할 수 있고</li><li><strong>사용한 만큼</strong> 요금을 내는 서비스</li></ol></blockquote></li></ul><h1 id="2-클라우드-컴퓨팅의-등장배경"><a href="#2-클라우드-컴퓨팅의-등장배경" class="headerlink" title="2. 클라우드 컴퓨팅의 등장배경"></a>2. 클라우드 컴퓨팅의 등장배경</h1><h2 id="정보처리-시스템의-흐름"><a href="#정보처리-시스템의-흐름" class="headerlink" title="정보처리 시스템의 흐름"></a>정보처리 시스템의 흐름</h2><ul><li>메인프레임 - 1980년대</li><li>분산형 클라이언트 서버 모델- 1990년대</li><li>사내 인트라넷 → 서버에 집중 - 2000년대</li><li>클라우드 컴퓨팅 - 2010년대<ul><li>전 세계에 분산 배치된 서버 리소스를 <u>필요한 때</u> <u>필요한 만큼</u> 사용</li></ul></li></ul><h2 id="정보처리-시스템의-흐름-1"><a href="#정보처리-시스템의-흐름-1" class="headerlink" title="정보처리 시스템의 흐름"></a>정보처리 시스템의 흐름</h2><ul><li>CPU 고속화</li><li>가상화 기술 및 분산 처리 기술</li><li>빠르고 저렴한 네트워크</li><li>거대해진 데이터 센터 (delf: 클라우드 서비스에 종속?)</li><li>사용자(기업) - IT 투자 비용 절감</li><li>사업자(클라우드 서비스 제공자) - 지속적 매출</li></ul><h1 id="3-클라우드-정의"><a href="#3-클라우드-정의" class="headerlink" title="3. 클라우드 정의"></a>3. 클라우드 정의</h1><p>NIST (미국 국립 표준 기술연구소) 정의 - <a href="http://www.ipa.go.jp/files/000025366.pdf" target="_blank" rel="noopener">www.ipa.go.jp/files/000025366.pdf</a></p><blockquote><p>공유 구성이 가능한 컴퓨팅 리소스의 통합을 통해 어디서나 간편하게, 요청에 따라 네트워크를 통해 접근하는 것을 가능하게 하는 모델. 이는 최소한의 이용 절차 또는 서비스 공급자의 상호 작용을 통해, 신속히 할당되어 제공된다.</p></blockquote><h1 id="4-클라우드-특징"><a href="#4-클라우드-특징" class="headerlink" title="4. 클라우드 특징"></a>4. 클라우드 특징</h1><ul><li>주문형 셀프 서비스 - 사용자 스스로 개별 관리</li><li>광범위한 네트워크 접속</li><li>리소스 공유 (delf: 가상화 기술)</li><li>신속한 확장성 - Scale Up/Down</li><li>측정 가능한 서비스 - 종량제</li></ul><h1 id="5-클라우드-서비스-모델"><a href="#5-클라우드-서비스-모델" class="headerlink" title="5. 클라우드 서비스 모델"></a>5. 클라우드 서비스 모델</h1><ul><li>IaaS (Infrastructure as a Service)</li><li>Paas (Platform as a Service)</li><li>Saas (Software as a Service)</li></ul><p><img src="/post_resources/2018-09-11/cloudmodel.png" alt=""><br>참고: <a href="https://www.ibm.com/cloud/learn/iaas-paas-saas" target="_blank" rel="noopener">https://www.ibm.com/cloud/learn/iaas-paas-saas</a>   </p><h2 id="IaaS-Infrastructure-as-a-Service"><a href="#IaaS-Infrastructure-as-a-Service" class="headerlink" title="IaaS (Infrastructure as a Service)"></a>IaaS (Infrastructure as a Service)</h2><ul><li>사업자는 사용자에게 pay-as-you-go access 제공</li><li>Storage, Networking, Servers, …</li></ul><p><img src="/post_resources/2018-09-11/infrastructure-as-a-service-iaas.jpg" alt=""></p><h2 id="PaaS-Platform-as-a-Service"><a href="#PaaS-Platform-as-a-Service" class="headerlink" title="PaaS (Platform as a Service)"></a>PaaS (Platform as a Service)</h2><ul><li>사업자는 Cloud-based environment + Infrastructure 제공</li><li>사용자는 Application 개발</li><li>Java, PHP, Ruby 등의 프로그래밍 언어를 지원하는 애플리케이션 실행 환경이나 데이터베이스 등이 미리 준비되어 있음</li><li>개발 및 테스트에 큰 처리 능력이 필요한 경우</li><li>자사에서 운영 중인 애플리케이션의 최대 부하를 분산 처리할 때</li><li>IoT 데이터를 효율적으로 수집하여 처리하는 플랫폼</li><li>Force.com</li></ul><p><img src="/post_resources/2018-09-11/platform-as-a-service-paas.jpg" alt=""></p><h2 id="SaaS-Software-as-a-Service"><a href="#SaaS-Software-as-a-Service" class="headerlink" title="SaaS (Software as a Service)"></a>SaaS (Software as a Service)</h2><ul><li>사업자는 사용자에게 software/application 제공</li><li>사용자는 subscrible를 하고 web 또는 API를 통해 access</li></ul><p><img src="/post_resources/2018-09-11/software-as-a-service-saas.jpg" alt=""></p><h2 id="클라우드-서비스-모델-참고-from-MS"><a href="#클라우드-서비스-모델-참고-from-MS" class="headerlink" title="클라우드 서비스 모델 참고 - from MS"></a>클라우드 서비스 모델 참고 - from MS</h2><ul><li><a href="https://azure.microsoft.com/ko-kr/overview/what-is-iaas/" target="_blank" rel="noopener">MS Azure IaaS란?</a></li><li><a href="https://azure.microsoft.com/ko-kr/overview/what-is-paas/" target="_blank" rel="noopener">MS Azure PaaS란?</a></li><li><a href="https://azure.microsoft.com/ko-kr/overview/what-is-saas/" target="_blank" rel="noopener">MS Azure SaaS란?</a></li></ul><h3 id="Cloud-Service-⟺︎-On-premise"><a href="#Cloud-Service-⟺︎-On-premise" class="headerlink" title="Cloud Service ⟺︎ On-premise"></a>Cloud Service ⟺︎ On-premise</h3><ul><li>회사 내에 자체적으로 데이터 센터를 보유</li><li>시스템 구축, 운용까지 직접 수행하는 형태</li></ul><h1 id="6-1-클라우드-컴퓨팅의-장점"><a href="#6-1-클라우드-컴퓨팅의-장점" class="headerlink" title="6-1. 클라우드 컴퓨팅의 장점"></a>6-1. 클라우드 컴퓨팅의 장점</h1><ul><li><strong>경제성</strong>: 사용하고자 하는 기간만, 소프트웨어/데이터를 클라우드에서 통합 관리</li><li><strong>유연성</strong>: 리소스를 필요할 때, 필요한 만큼 확장/축소 가능</li><li><strong>가용성</strong>: 장애 발생시 계속 사용 가능</li><li>빠른 구축 속도</li><li>손쉬운 글로벌 서비스(ex. 넷마블의 해외 서바스)</li><li>강력한 보안</li></ul><h1 id="6-2-클라우드-컴퓨팅의-단점"><a href="#6-2-클라우드-컴퓨팅의-단점" class="headerlink" title="6-2. 클라우드 컴퓨팅의 단점"></a>6-2. 클라우드 컴퓨팅의 단점</h1><ul><li>생각보다 비싼 비용</li><li>점점 커지는 클라우드 의존성</li><li>데이터 보관의 불안함</li></ul><h1 id="클라우드-이용-모델"><a href="#클라우드-이용-모델" class="headerlink" title="클라우드 이용 모델"></a>클라우드 이용 모델</h1><ul><li>Deployment model</li><li>Private cloud</li><li>Community cloud</li><li>Public cloud</li><li>Hybrid cloud</li></ul><h2 id="Private-cloud"><a href="#Private-cloud" class="headerlink" title="Private cloud"></a>Private cloud</h2><ul><li>독점적으로 사용되는 클라우드 컴퓨팅 리소스</li><li>클라우드 서비스 사용자 또는 사업자의 데이터 센터에 구축한 자사 전용 환경</li><li>서비스와 인프라가 개인/기업네트워크에서 유지 관리 됨</li></ul><h2 id="Community-cloud"><a href="#Community-cloud" class="headerlink" title="Community cloud"></a>Community cloud</h2><ul><li>공통의 목적을 가진 기업/조직들이 클라우드 시스템을 형성하여 데이터 센터에서 <strong>공동 운영</strong>하는 형태</li></ul><h2 id="Public-cloud"><a href="#Public-cloud" class="headerlink" title="Public cloud"></a>Public cloud</h2><ul><li>클라우드 사업자가 시스템 구축</li><li>네트워크를 통해 기업, 개인에게 서비스 제공</li><li>기업/개인 방화벽 외부에 구축됨</li></ul><h2 id="Hybrid-cloud"><a href="#Hybrid-cloud" class="headerlink" title="Hybrid cloud"></a>Hybrid cloud</h2><ul><li>Public, Private, Community 서비스들과 On-premise 시스템을 연계시켜 활용하는 시스템</li></ul><h3 id="Private-cloud-종류"><a href="#Private-cloud-종류" class="headerlink" title="Private cloud 종류"></a>Private cloud 종류</h3><ul><li>On-premise private cloud<ul><li>자사 전용 클라우드 환경 구축, 운용</li><li>자체적인 보안정책 → 강력한 보안 환경 부담</li></ul></li><li>Hosted private cloud<ul><li>클라우드 사업자가 기업 사용자별로 클라우드 환경 제공</li><li>기업 전용 클라우드 환경 구축 → 비용 지불</li></ul></li></ul><p><img src="/post_resources/2018-09-11/kind-of-cloud-model.png" alt=""></p><h1 id="클라우드의-안정성과-신뢰성"><a href="#클라우드의-안정성과-신뢰성" class="headerlink" title="클라우드의 안정성과 신뢰성"></a>클라우드의 안정성과 신뢰성</h1><ul><li>클라우드 리스크</li><li>장비 고장 리스크</li><li>재해, 운영자의 조작 실수 등의 리스크</li><li>통신 도청 리스크</li><li>중간자 공격</li><li>스푸핑</li><li>클라우드 사업자의 파산 또는 서비스 중단<br>…<h2 id="클라우드의-보안-거버넌스"><a href="#클라우드의-보안-거버넌스" class="headerlink" title="클라우드의 보안 거버넌스"></a>클라우드의 보안 거버넌스</h2></li><li>기업 경영진이 클라우드를 이용할 때의 위험을 주체적이고 적절하게 관리하기 위한 구조를 구축하고 운용하는 것</li><li>보안 등의 리스크를 모두 통제할 수 없다 → 클라우드 서비스의 연속성 리스크</li></ul><h1 id="8-클라우드-도입"><a href="#8-클라우드-도입" class="headerlink" title="8. 클라우드 도입"></a>8. 클라우드 도입</h1><h2 id="중소기업의-클라우드-도입"><a href="#중소기업의-클라우드-도입" class="headerlink" title="중소기업의 클라우드 도입"></a>중소기업의 클라우드 도입</h2><ul><li>중소기업의 IT 활용 부진의 요인 - 비용, 인재의 부족</li><li>클라우드 도입의 장점: 기업의 가치 창출, 성장에 대비</li><li>정보 시스템 담당자<ul><li>비용 절약</li><li>시장 환경 변화에 따라 유연하게 시스템을 변화시킬 수 있음</li></ul></li><li>경영진<ul><li>IT에 투자하는 경영 자원의 최소화</li><li>핵심 역량에 경영 자원 집중 가능</li></ul></li></ul><h2 id="대기업의-클라우드-도입"><a href="#대기업의-클라우드-도입" class="headerlink" title="대기업의 클라우드 도입"></a>대기업의 클라우드 도입</h2><ul><li>세계 시장 진출시 손쉬운 글로벌화</li><li>글로벌하게 전개할 수 있는 효율적인 업무 프로세스 구조 구축</li><li>신속한 시스템 도입 및 운영으로부터의 해방</li></ul>]]></content>
    
    <summary type="html">
    
      클라우드 컴퓨팅에 대한 소개
    
    </summary>
    
      <category term="Study" scheme="https://delf-lee.github.io/categories/study/"/>
    
    
      <category term="Cloud" scheme="https://delf-lee.github.io/tags/cloud/"/>
    
  </entry>
  
  <entry>
    <title>Java의 Comparable과 Comparator</title>
    <link href="https://delf-lee.github.io/Comparable-and-Comparator/"/>
    <id>https://delf-lee.github.io/Comparable-and-Comparator/</id>
    <published>2018-09-02T13:36:05.000Z</published>
    <updated>2018-09-11T08:43:09.268Z</updated>
    
    <content type="html"><![CDATA[<hr><!-- ![](/post_resources/2018-09-08/1_title.png){: width="100"){: .center} --><p><img src="/post_resources/2018-09-08/1_title.png" width="400"></p><h1 id="개요"><a href="#개요" class="headerlink" title="개요"></a>개요</h1><ol><li>배열 안의 요소 정렬</li><li>객체들의 정렬<ul><li><code>Comparable</code> interface</li><li><code>Comparator</code> interface</li></ul></li><li>예제</li></ol><h1 id="1-배열의-안의-요소-정렬"><a href="#1-배열의-안의-요소-정렬" class="headerlink" title="1. 배열의 안의 요소 정렬"></a>1. 배열의 안의 요소 정렬</h1><p>배열 안의 요소는 Java API에서 제공하는 <code>sort()</code>메서드를 이용하면 쉽게 정렬이 가능합니다.<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span>[] nums = &#123;<span class="number">4</span>, <span class="number">1</span>, <span class="number">3</span>, <span class="number">2</span>, <span class="number">5</span>&#125;;</span><br><span class="line">Arrays.sort(nums); <span class="comment">// 결과: 1, 2, 3, 4, 5</span></span><br><span class="line"></span><br><span class="line">String[] strs  = &#123;<span class="string">"D"</span>, <span class="string">"A"</span>, <span class="string">"B"</span>, <span class="string">"E"</span>, <span class="string">"C"</span>&#125;;</span><br><span class="line">Arrays.sort(strs); <span class="comment">// 결과: "A", "B", "C", "D", "E"</span></span><br></pre></td></tr></table></figure></p><p>이렇게 정렬이 가능한 이유는 각 요소를 <strong>비교</strong>할 수 있기 때문입니다. 1보다는 2가 크고, A보다는 B가 크죠.</p><p>하지만 아래와 같은 <code>Student</code> 인스턴스가 여러게 있다면, 과연 어떤게 <em>‘먼저’</em> 일까요?<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Student</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> String name;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span> age;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h1 id="2-객체들의-정렬"><a href="#2-객체들의-정렬" class="headerlink" title="2. 객체들의 정렬"></a>2. 객체들의 정렬</h1><p>사용자가 생성한 임의의 객체들을 정렬하기 위해서는 <strong>기준</strong>이 필요합니다. 즉 객체의 <strong>비교</strong>가 가능하다면 정렬을 할 수 있게됩니다.<br>어떤게 더 큰지, 어떤게 더 먼저인지 비교가 가능하다면, 그 기준에 따라 정렬이 가능하죠.</p><h2 id="Comparable-interface"><a href="#Comparable-interface" class="headerlink" title="Comparable interface"></a><code>Comparable</code> interface</h2><p>그 <strong>기준</strong>을 정의하기 위해서는 해당 class에 <code>Comparable</code> interface를 구현현하는 방법 이 있습니다. <code>CompareTo()</code>메소드를 오버라이드 하여 인스턴스에 대하여 비교 기준을 정의해야 합니다.</p><blockquote><p><u><code>Comparable</code>은 정렬 수행시 기본적으로 적용되는 정렬 기준이 되는 메서드를 정의해 놓는 인터페이스</u>입니다. </p></blockquote><p>사실, 위에서 <code>Arrays</code>를 이용하여 정렬한 배열안의 요소(객체)를 포함한 대부분의 Java의 기본 자료형들은 <code>Comparable</code> interface를 구현하고 있습니다.  </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Integer class</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">Integer</span> <span class="keyword">extends</span> <span class="title">Number</span> <span class="keyword">implements</span> <span class="title">Comparable</span>&lt;<span class="title">Integer</span>&gt; </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// String class</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">String</span></span></span><br><span class="line"><span class="class">    <span class="keyword">implements</span> <span class="title">java</span>.<span class="title">io</span>.<span class="title">Serializable</span>, <span class="title">Comparable</span>&lt;<span class="title">String</span>&gt;, <span class="title">CharSequence</span> </span>&#123;</span><br><span class="line">        ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>Comparable</code> interface를 구현하여 <code>Student</code>의 객체들을 나이(age)순으로 정렬하고자 한다면, 다음과 같이 정의할 수 있습니다.<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Student</span> <span class="keyword">implements</span> <span class="title">Comparable</span>&lt;<span class="title">Student</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> String name;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span> age;</span><br><span class="line">    ...</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compareTo</span><span class="params">(Student o)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> Integer.compare(<span class="keyword">this</span>.age, o.age);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><code>CompareTo()</code>의 반환값이 양수라면 내부 정렬 알고리즘에서 두 요소를 비교할 때 자리를 바꾸고, 0이나 음수라면 바꾸지 않습니다.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">Student[] arr = <span class="keyword">new</span> Student[<span class="number">5</span>];</span><br><span class="line">arr[<span class="number">0</span>] = <span class="keyword">new</span> Student(<span class="string">"A"</span>, <span class="number">26</span>);</span><br><span class="line">arr[<span class="number">1</span>] = <span class="keyword">new</span> Student(<span class="string">"B"</span>, <span class="number">27</span>);</span><br><span class="line">arr[<span class="number">2</span>] = <span class="keyword">new</span> Student(<span class="string">"C"</span>, <span class="number">27</span>);</span><br><span class="line">arr[<span class="number">3</span>] = <span class="keyword">new</span> Student(<span class="string">"D"</span>, <span class="number">21</span>);</span><br><span class="line">arr[<span class="number">4</span>] = <span class="keyword">new</span> Student(<span class="string">"E"</span>, <span class="number">20</span>);</span><br><span class="line"></span><br><span class="line">List&lt;Student&gt; students = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"><span class="keyword">for</span> (Student student : arr) </span><br><span class="line">    students.add(student);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 기본 배열에서의 정렬</span></span><br><span class="line">Arrays.sort(arr); <span class="comment">// 결과: E(20), D(21), B(27), A(26), C(27)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// List Collection에서의 정렬</span></span><br><span class="line">Collections.sort(students); <span class="comment">// 결과: E(20), D(21), B(27), A(26), C(27)</span></span><br></pre></td></tr></table></figure><h2 id="Comparator-interface"><a href="#Comparator-interface" class="headerlink" title="Comparator interface"></a><code>Comparator</code> interface</h2><p>그렇다면 <code>Student</code> 객체들을 <em>이름 순</em>으로 정렬하고 싶다면? <em>나이 내림차순</em>으로 정리하고 싶다면 어떡할까요?<br>정렬할 때 마다 <code>Student</code> class의 코드를 수정해야할까요?</p><p>이럴 때 쓰이는 것이 바로 <code>Comparator</code> interface입니다.  </p><blockquote><p><code>Comparator</code>는 <u>기본 정렬 기준(<code>Comparable</code>을 구현하여 정의한 기준)과는 다른 방식으로 정렬하고 싶을 때 사용하는 인터페이스</u>입니다. </p></blockquote><p>다른 기준의 정렬 조건을 정의하기 위해선 <code>Comparator</code>를 interface를 구현하고 <code>compare()</code>메서드를 작성해야 합니다. 여기서는 간단하게 익명 클래스(Anonymouse class)로 구현하겠습니다.<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">Student[] arr = <span class="keyword">new</span> Student[<span class="number">5</span>];</span><br><span class="line">arr[<span class="number">0</span>] = <span class="keyword">new</span> Student(<span class="string">"A"</span>, <span class="number">26</span>);</span><br><span class="line">arr[<span class="number">1</span>] = <span class="keyword">new</span> Student(<span class="string">"B"</span>, <span class="number">27</span>);</span><br><span class="line">arr[<span class="number">2</span>] = <span class="keyword">new</span> Student(<span class="string">"C"</span>, <span class="number">27</span>);</span><br><span class="line">arr[<span class="number">3</span>] = <span class="keyword">new</span> Student(<span class="string">"D"</span>, <span class="number">21</span>);</span><br><span class="line">arr[<span class="number">4</span>] = <span class="keyword">new</span> Student(<span class="string">"E"</span>, <span class="number">20</span>);</span><br><span class="line"></span><br><span class="line">List&lt;Student&gt; students = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"><span class="keyword">for</span> (Student student : arr) </span><br><span class="line">    students.add(student);</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Comparator 익명클래스 정의 */</span></span><br><span class="line">Comparator&lt;Student&gt; descNameComparator = <span class="keyword">new</span> Comparator&lt;Student&gt;() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compare</span><span class="params">(Student s1, Student s2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> s2.name.compareTo(s1.name); <span class="comment">// 이름에 대하여 내림차순</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// 기본 배열에서의 정렬</span></span><br><span class="line">Arrays.sort(arr, descNameComparator); <span class="comment">// 결과: E(20), D(21), C(27), B(24), A(26)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// List Collection에서의 정렬</span></span><br><span class="line">Collections.sort(stdents, descNameComparator); <span class="comment">// 결과: E(20), D(21), C(27), B(24), A(26)</span></span><br></pre></td></tr></table></figure></p><p>이름을 내림차순으로 정렬하기 위하여 String의 비교 값을 출력하였습니다. 이와 같이 <code>Comparator</code> 인터페이스를 구현하면, 임의의 사용자 객체에 대하여 여러 종류의 기준으로 정렬이 가능합니다.</p><p>조건문을 통해 <code>compare()</code>메서드의 반환값을 제어해 준다면 정렬 기준을 중복하여 적용할 수 있습니다. 이는 <code>Comparable</code> 인터페이스의 <code>compareTo()</code>메서드도 마찬가지입니다.<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 나이 역순으로 정렬. 나이가 같다면 이름순으로 정렬.</span></span><br><span class="line">Comparator&lt;Student&gt; myComparator = <span class="keyword">new</span> Comparator&lt;Student&gt;() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compare</span><span class="params">(Student s1, Student s2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(s1.age == s2.age) &#123;</span><br><span class="line">            <span class="keyword">return</span> s1.name.compareTo(s2.name);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> Integer.compare(s2.age, s1.age);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><h1 id="3-예제"><a href="#3-예제" class="headerlink" title="3. 예제"></a>3. 예제</h1><p>위 설명을 기반으로 한 예제 코드입니다.<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String args[])</span> </span>&#123;</span><br><span class="line">        <span class="comment">// Student 배열 인스턴스 생성</span></span><br><span class="line">        Student[] arr = <span class="keyword">new</span> Student[<span class="number">5</span>];</span><br><span class="line">        arr[<span class="number">0</span>] = <span class="keyword">new</span> Student(<span class="string">"A"</span>, <span class="number">26</span>);</span><br><span class="line">        arr[<span class="number">1</span>] = <span class="keyword">new</span> Student(<span class="string">"B"</span>, <span class="number">27</span>);</span><br><span class="line">        arr[<span class="number">2</span>] = <span class="keyword">new</span> Student(<span class="string">"C"</span>, <span class="number">27</span>);</span><br><span class="line">        arr[<span class="number">3</span>] = <span class="keyword">new</span> Student(<span class="string">"D"</span>, <span class="number">21</span>);</span><br><span class="line">        arr[<span class="number">4</span>] = <span class="keyword">new</span> Student(<span class="string">"E"</span>, <span class="number">20</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Student List Collection 인스턴스 생성</span></span><br><span class="line">        List&lt;Student&gt; students = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (Student student : arr)</span><br><span class="line">            students.add(student);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 기본 배열에서의 정렬(Comparable interface)</span></span><br><span class="line">        Arrays.sort(arr);</span><br><span class="line">        System.out.println(Arrays.asList(arr)); <span class="comment">// E(20), D(21), B(27), A(26), C(27)</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// List Collection에서의 정렬(Comparable interface)</span></span><br><span class="line">        Collections.sort(students);</span><br><span class="line">        System.out.println(students); <span class="comment">// E(20), D(21), B(27), A(26), C(27)</span></span><br><span class="line"></span><br><span class="line">        System.out.println();</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* Comparator 익명클래스 정의 */</span></span><br><span class="line">        Comparator&lt;Student&gt; descNameComparator = <span class="keyword">new</span> Comparator&lt;Student&gt;() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compare</span><span class="params">(Student s1, Student s2)</span> </span>&#123;</span><br><span class="line">                <span class="keyword">return</span> s2.name.compareTo(s1.name); <span class="comment">// 이름에 대하여 내림차순</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 기본 배열에서의 정렬(Comparator interface)</span></span><br><span class="line">        Arrays.sort(arr, descNameComparator);</span><br><span class="line">        System.out.println(Arrays.asList(arr)); <span class="comment">// E(20), D(21), C(27), B(27), A(26)</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// List Collection에서의 정렬(Comparator interface)</span></span><br><span class="line">        Collections.sort(students, descNameComparator);</span><br><span class="line">        System.out.println(students); <span class="comment">// E(20), D(21), C(27), B(27), A(26)</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Student</span> <span class="keyword">implements</span> <span class="title">Comparable</span>&lt;<span class="title">Student</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> String name;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span> age;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Student</span><span class="params">(String name, <span class="keyword">int</span> age)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">        <span class="keyword">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compareTo</span><span class="params">(Student o)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> Integer.compare(<span class="keyword">this</span>.age, o.age); <span class="comment">// 나이에 대하여 오름차순</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> name + <span class="string">"("</span> + age + <span class="string">")"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h3><ul><li><a href="http://hochulshin.com/java-comparable-comparator/" target="_blank" rel="noopener">http://hochulshin.com/java-comparable-comparator/</a></li><li><a href="http://cwondev.tistory.com/15" target="_blank" rel="noopener">http://cwondev.tistory.com/15</a></li><li><a href="https://docs.oracle.com/javase/8/docs/api/java/lang/Comparable.html" target="_blank" rel="noopener">https://docs.oracle.com/javase/8/docs/api/java/lang/Comparable.html</a></li><li><a href="https://docs.oracle.com/javase/8/docs/api/java/util/Comparator.html" target="_blank" rel="noopener">https://docs.oracle.com/javase/8/docs/api/java/util/Comparator.html</a></li></ul>]]></content>
    
    <summary type="html">
    
      Java에서 임의의 객체를 담은 배열을 정렬하기 위해 Comparable과 Comparator의 사용 방법에 대해서 알아봅니다.
    
    </summary>
    
    
      <category term="Java" scheme="https://delf-lee.github.io/tags/java/"/>
    
  </entry>
  
</feed>
