<?xml version="1.0" encoding="utf-8"?>
<search> 
  
    
    <entry>
      <title>Cloud Computing를 사용하는 이유</title>
      <link href="/Why-Cloud-Computing/"/>
      <url>/Why-Cloud-Computing/</url>
      <content type="html"><![CDATA[<p><img src="/post_resources/2018-09-18/title.png" alt=""><br>AWS에서 이야기 해주는 Cloud Computing의 장점에 대한 글입니다. 누가 “클라우드 그거 왜 쓰는거야?”라고 물는다면, 이 글이 대답하는데 도움이 될 수 있겠군요!</p><h1 id="Cloud-Computing의-6가지-이점"><a href="#Cloud-Computing의-6가지-이점" class="headerlink" title="Cloud Computing의 6가지 이점"></a>Cloud Computing의 6가지 이점</h1><ol><li>초기 선투지 비용 없음</li><li>운영 비용 절감</li><li>탄력적인 운영 및 확장</li><li>속도 및 민첩성</li><li>비즈니스에만 집중 가능</li><li>글로벌 확장<br><img src="/post_resources/2018-09-18/1.png" alt=""></li></ol><h2 id="1-초기-선투자-비용-없음"><a href="#1-초기-선투자-비용-없음" class="headerlink" title="1) 초기 선투자 비용 없음"></a>1) 초기 선투자 비용 없음</h2><p><img src="/post_resources/2018-09-18/2.png" alt=""><br>큰 비용과 시간을 소모하는 데이터센터를 구매하고 운용할 필요가 없습니다. 클릭 몇 번으로 수 분 내에 원하는 성능의 서버를 구축할 수 있습니다.</p><ul><li>On-premis: Cloud와 상반되는 개념으로, 기존의 물리적인 데이터센터(서버)를 운용하는 것.</li></ul><h2 id="2-운영-비용-절감"><a href="#2-운영-비용-절감" class="headerlink" title="2) 운영 비용 절감"></a>2) 운영 비용 절감</h2><p>고정된 서버는 최대 트래픽치를 예상하여 구축합니다. 때문에 트래픽이 줄었을 경우에는 자원의 낭비가 발생하고, 수용 범위를 초과한 경우에는 서비스가 느려지거나 중단되는 등의 문제가 발생합니다.<br><img src="/post_resources/2018-09-18/3.png" alt=""></p><ul><li>On and Off<ul><li>서버가 중지되고 있는 시간 만큼 자원의 낭비가 발생합니다.</li></ul></li><li>Fast Growth<ul><li>빠른 성장으로 사용자의 유입이 늘어난다면, 적지 않은 비용을 들여 성능 향상을 해주어야 합니다. 미래의 트래픽을 예상하기 힘들고, 비용문제로 잦은 성능 향상은 부담입니다.</li></ul></li><li>Variable peaks<ul><li>유동적인 트래픽 대응하기 어렵습니다. 서버의 성능이 낮다면 많은 사용자를 수용할 수 없고, 성능이 과하게 좋다면 자원의 낭비가 될 수 있습니다.</li></ul></li><li>Predictable peaks<ul><li>트래픽이 많은 일정 시간대(게다가 예상할 수 있는)만을 위한 서버 능력은 자원의 낭비가 될 수 있습니다.</li></ul></li></ul><p><img src="/post_resources/2018-09-18/4.png" alt=""><br>전력, 항온항습, 상면 비용 등의 물리적인 데이터센터를 유지하는 비용과 이를 운영, 관리하는 인력에 소모되는 비용, 소프트웨어의 버전 업에 따른 라이선스 변경과 그 비용, 그리고 향후에 서버를 증설하는 비용까지 On-premise 방식에는 운영하는데 신경 써야 할 요소가 많습니다.</p><h2 id="3-탄력적인-운영-및-확장"><a href="#3-탄력적인-운영-및-확장" class="headerlink" title="3) 탄력적인 운영 및 확장"></a>3) 탄력적인 운영 및 확장</h2><p><img src="/post_resources/2018-09-18/5.png" alt=""><br>트래픽의 변동에 유연하게 대응할 수 있습니다. 이는 서버의 안정성이 늘어남에 따라 사용자에게 만족감을 줄 수 있을뿐더러, 서버를 효율적으로 운영하여 비용절감이 가능합니다.</p><h2 id="4-속도-및-민첩성"><a href="#4-속도-및-민첩성" class="headerlink" title="4) 속도 및 민첩성"></a>4) 속도 및 민첩성</h2><p>적은 비용으로 손쉽게 애플리케이션을 배포가 가능하기 때문에 서비스 구현 속도가 빨라지고, 더 많은 시도를 할 수 있습니다.</p><h3 id="On-premises-vs-Cloud-Computing-AWS"><a href="#On-premises-vs-Cloud-Computing-AWS" class="headerlink" title="On-premises vs Cloud Computing(AWS)"></a>On-premises vs Cloud Computing(AWS)</h3><ul><li>혁신을 위한 시도가 자주 일어나지 않는다 <strong>↔</strong> 혁신을 위한 시도를 많이 할 수 있다</li><li>실패의 비용이 높다 <strong>↔</strong> 실패의 비용이 낮다</li><li>혁신의 속도가 느려진다 <strong>↔</strong> 많은 혁신이 가능하다<br><img src="/post_resources/2018-09-18/6.png" alt=""></li></ul><h2 id="5-비즈니에스에만-집중-가능"><a href="#5-비즈니에스에만-집중-가능" class="headerlink" title="5) 비즈니에스에만 집중 가능"></a>5) 비즈니에스에만 집중 가능</h2><p><img src="/post_resources/2018-09-18/7.png" alt=""><br>서버의 운영부터, 보안, 라이센스, 증설 및 확장 등의 문제에 대해서 자유로워질 수 있습니다.</p><h2 id="6-글로벌-확장"><a href="#6-글로벌-확장" class="headerlink" title="6) 글로벌 확장"></a>6) 글로벌 확장</h2><p><img src="/post_resources/2018-09-18/8.png" alt=""><br>전용 데이터센터가 전세계 곳곳에 구축되어 있기 때문에, 따로 데이터 센터를 구축 할 필요 없이 손쉽게 글로벌 서비스가 가능합니다.</p><h2 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h2><ul><li><a href="https://www.youtube.com/watch?v=KBzkeuX32XY" target="_blank" rel="noopener">https://www.youtube.com/watch?v=KBzkeuX32XY</a></li><li><a href="https://aws.amazon.com/ko/blogs/korea/tag/webinar/" target="_blank" rel="noopener">https://aws.amazon.com/ko/blogs/korea/tag/webinar/</a></li></ul>]]></content>
      
      <categories>
          
          <category> Study </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Interview </tag>
            
            <tag> Cloud </tag>
            
            <tag> AWS </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>제네릭(Generic)이란?</title>
      <link href="/Java-Generic/"/>
      <url>/Java-Generic/</url>
      <content type="html"><![CDATA[<h1 id="개요"><a href="#개요" class="headerlink" title="개요"></a>개요</h1><h1 id="제네릭-Generic-이란"><a href="#제네릭-Generic-이란" class="headerlink" title="제네릭(Generic)이란?"></a>제네릭(Generic)이란?</h1><ul><li>클래스에서 사용할 타입을 클래스 외부에서 설정하는 것</li><li>클래스 내부 데이터 타입을 <u>인스턴스를 생성할 때</u> 확정하는 것</li></ul><h1 id="제네릭의-활용"><a href="#제네릭의-활용" class="headerlink" title="제네릭의 활용"></a>제네릭의 활용</h1><h2 id="제네릭-클래스"><a href="#제네릭-클래스" class="headerlink" title="제네릭 클래스"></a>제네릭 클래스</h2><p>클래스 생성 시, 내부에서 사용할 필드의 타입을 지정할 수 있습니다. 이를 이용하여 다음과 같이 간단한 List를 구현할 수 있습니다.<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// SimpleList 정의</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SimpleList</span>&lt;<span class="title">E</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> &lt;T&gt; elements;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">SimpleList</span><span class="params">(<span class="keyword">int</span> size)</span> </span>&#123; (E[]) elements = <span class="keyword">new</span> Object[size]; &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>클래스의 인스턴스를 생성하기 위해선 반드시 타입을 명시해주어야 합니다.<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// SimpleList 사용</span></span><br><span class="line">SimpleList&lt;String&gt; sList = <span class="keyword">new</span> SimpleList&lt;&gt;(<span class="number">100</span>);</span><br><span class="line">sList.add(<span class="string">"123"</span>);</span><br><span class="line">sList.add(<span class="string">"456"</span>);</span><br><span class="line">System.out.println(sList.get(<span class="number">0</span>) + sList.get(<span class="number">1</span>)); <span class="comment">// "123456"</span></span><br><span class="line"></span><br><span class="line">SimpleList&lt;Integer&gt; iList = <span class="keyword">new</span> SimpleList&lt;&gt;(<span class="number">100</span>);</span><br><span class="line">iList.add(<span class="number">123</span>);</span><br><span class="line">iList.add(<span class="number">456</span>);</span><br><span class="line">System.out.println(iList.get(<span class="number">0</span>) + iList.get(<span class="number">1</span>)); <span class="comment">// 579</span></span><br></pre></td></tr></table></figure></p><p><a href="">전체 코드 보기(Gist)</a></p><h2 id="제네릭-인터페이스"><a href="#제네릭-인터페이스" class="headerlink" title="제네릭 인터페이스"></a>제네릭 인터페이스</h2><p>제네릭 클래스와 마찬가지로</p><p>메서드 파라미터에 타입 파라미터도 선언되어 있다면, 메서드 리턴 타입 앞에 꼭 제네릭 타입이 선언되어야 한다.</p><pre><code class="java"><span class="class"><span class="keyword">class</span> <span class="title">GenericMethod</span> </span>{    <span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; <span class="function"><span class="keyword">int</span> <span class="title">getListSize</span><span class="params">(List&lt;T&gt; list)</span> </span>{        <span class="keyword">int</span> count = <span class="number">0</span>;        <span class="keyword">for</span> (T t : list) {            count++;        }        <span class="keyword">return</span> count;    }}</code></pre><h2 id="제네릭-메서드"><a href="#제네릭-메서드" class="headerlink" title="제네릭 메서드"></a>제네릭 메서드</h2><h1 id="제네릭의-장점과-사용하는-이유"><a href="#제네릭의-장점과-사용하는-이유" class="headerlink" title="제네릭의 장점과 사용하는 이유"></a>제네릭의 장점과 사용하는 이유</h1><ol><li><strong>타입 안정성</strong>(type-safe)을 제공한다.<ul><li>코드를 작성할 때 사용할 데이터 타입을 분명하게 명시해주어 <em>컴파일 시의 타입 체크(compile-time type check)</em> 가 가능하여 에러를 사전에 방지할 수 있다.</li><li><strong>type-safe</strong>: Runtime 시 타입 체크로 인하여 예측 불가능한 문제가 발생하지 않음을 보장하는 것</li></ul></li><li>타입 체크와 형변환을 생략할 수 있으므로(컴퍼일러가 해주기 때문에) 코드가 깔끔해지고 간결해 진다.</li><li>타입의 종류만 바꾸면 되는 로직일 경우, 코드 재활용이 가능하다.</li></ol><h2 id="타입-명명-관례"><a href="#타입-명명-관례" class="headerlink" title="타입 명명 관례"></a>타입 명명 관례</h2><ul><li><strong>E</strong> - Element</li><li><strong>K</strong> - Key</li><li><strong>N</strong> - Number</li><li><strong>T</strong> - Type</li><li><strong>V</strong> - Value</li></ul><h3 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h3><ul><li><a href="https://github.com/JaeYeopHan/Interview_Question_for_Beginner/tree/master/Java#generic" target="_blank" rel="noopener">https://github.com/JaeYeopHan/Interview_Question_for_Beginner/tree/master/Java#generic</a></li><li><a href="http://devbox.tistory.com/entry/Java-제네릭" target="_blank" rel="noopener">http://devbox.tistory.com/entry/Java-제네릭</a></li><li><a href="https://medium.com/@ohjongsung/자바-제네렉-기본-1267798ffe8e" target="_blank" rel="noopener">https://medium.com/@ohjongsung/자바-제네렉-기본-1267798ffe8e</a></li><li><a href="http://devhong.tistory.com/19" target="_blank" rel="noopener">http://devhong.tistory.com/19</a></li></ul>]]></content>
      
      <categories>
          
          <category> Study </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Interview </tag>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>객체지향(Object-Oriented)이란?</title>
      <link href="/Object-Oriented/"/>
      <url>/Object-Oriented/</url>
      <content type="html"><![CDATA[<p><img src="../post_resources/2018-09-13/title_OOP.jpg" alt=""></p><h1 id="객체지향-Object-Oriented-이란"><a href="#객체지향-Object-Oriented-이란" class="headerlink" title="객체지향(Object-Oriented)이란?"></a>객체지향(Object-Oriented)이란?</h1><h2 id="객체-Object"><a href="#객체-Object" class="headerlink" title="객체(Object)"></a>객체(Object)</h2><blockquote><p>현실세계의 실체 및 개념을 반영하는 상태(Status)와 행위(Behavior)를 정의한 데이터의 집합</p></blockquote><h2 id="객체지향-Object-Oriented-프로그래밍"><a href="#객체지향-Object-Oriented-프로그래밍" class="headerlink" title="객체지향(Object-Oriented) 프로그래밍"></a>객체지향(Object-Oriented) 프로그래밍</h2><blockquote><p>각자의 역할을 지닌 <em>객체</em>들끼리 서로 메시지를 주고받으며 동작할 수 있도록 프로그래밍 하는 것</p></blockquote><h1 id="객체지향의-장점-강점"><a href="#객체지향의-장점-강점" class="headerlink" title="객체지향의 장점(강점)"></a>객체지향의 장점(강점)</h1><p>객체를 중심으로 프로그래밍하기 때문에,</p><ul><li>사람의 관점에서 프로그램을 이해하고 파악하기 쉽다.</li><li>강한 응집력(Strong Cohesion)과 약한 결합력(Weak Coupling)을 가진다.</li><li><em>재사용성</em>, <em>확장성</em>, <em>융통성</em>이 높다.</li></ul><p>이러한 장점 때문에 디버깅과 유지보수가 용이하고 설계과 분석이 비교적 쉽다.</p><h1 id="객체지향의-단점-한계"><a href="#객체지향의-단점-한계" class="headerlink" title="객체지향의 단점(한계)"></a>객체지향의 단점(한계)</h1><ul><li>객체 간의 정보 교환이 모두 메시지 교환을 통해 일어나므로 실행 시스템에 많은 overhead가 발생하게 된다.<ul><li>처리속도가 상대적으로 느리다.</li><li>하지만 하드웨어의 발전으로 이러한 단점은 어느정도 해소되었다. </li></ul></li><li>객체가 <em>상태를 갖기 때문에</em> 예상치 못한 부작용이 발생할 수 있다. 변수가 존재하고 이 변수를 통해 객체가 예측할 수 없는 상태를 갖게 되어 애플리케이션 내부에서 버그를 발생시킬 수 있다.<ul><li>이는 함수형 프로그래밍 등장의 패러다임이다.</li></ul></li></ul><h1 id="객체지향적-설계원칙-SOLID"><a href="#객체지향적-설계원칙-SOLID" class="headerlink" title="객체지향적 설계원칙 SOLID"></a>객체지향적 설계원칙 SOLID</h1><ul><li>SRP(Single Responsibility Principle)단일 책임 원칙<ul><li>클래스는 단 하나의 책임을 가져야 하며 클래스를 변경하는 이유는 단 하나의 이유이어야 한다.</li></ul></li><li>OCP(Open-Closed Principle) : 개방-폐쇄 원칙<ul><li>확장에는 열려 있어야 하고 변경에는 닫혀 있어야 한다.</li></ul></li><li>LSP(Liskov Substitution Principle) : 리스코프 치환 원칙<ul><li>상위 타입의 객체를 하위 타입의 객체로 치환해도 상위 타입을 사용하는 프로그램은 정상적으로 동작해야 한다.</li></ul></li><li>ISP(Interface Segregation Principle) : 인터페이스 분리 원칙<ul><li>인터페이스는 그 인터페이스를 사용하는 클라이언트를 기준으로 분리해야 한다.</li></ul></li><li>DIP(Dependency Inversion Principle) : 의존 역전 원칙<ul><li>고수준 모듈은 저수준 모듈의 구현에 의존해서는 안된다.</li></ul></li></ul><h1 id="객체지향의-특징"><a href="#객체지향의-특징" class="headerlink" title="객체지향의 특징"></a>객체지향의 특징</h1><h2 id="추상화"><a href="#추상화" class="headerlink" title="추상화"></a>추상화</h2><ul><li>객체에서 공통된 속성이나 기능을 추출하는 것.</li><li>중요하지 않은 것(관심 대상이 아닌 것)은 감추거나 무시하고, 중요한 것(관심있는 것)만을 강조하여 추출하는 것.</li><li>관점에 따라 추상화의 결과가 달라질 수 있다.</li><li>주요 관심사에만 집중함으로써, 프로그램의 복잡도를 관리할 수 있다.</li></ul><h2 id="캡슐화"><a href="#캡슐화" class="headerlink" title="캡슐화"></a>캡슐화</h2><p>관심있는 데이터와 기능을 모아놓고 패킹한 것이다. 객체지향에서는 이를 클래스로 정의하고 외부에서 마음대로 접근할 수 없게하였다. 과거 절차지향 프로그래밍에서는 소스코드가 거대해질수록 데이터가 어디서 어떻게 변화하는지 파악하기 어려웠고 유지보수가 힘들어지는 문제가 발생하였다. 객체지향 프로그래밍에서는 캡슐화를 통해 이란 폐단을 해결하였다. 이렇게 내부의 데이터나 함수를 외부에서 참조하지 못하도록 차단하는 개념을 정보 은닉화(Information Hiding)라고 하며 이것이 바로 캡슐화라는 개념이다.</p><h2 id="다형성"><a href="#다형성" class="headerlink" title="다형성"></a>다형성</h2><p>같은 코드라 하더라도 상황에 따라 다른 방식으로 동작하는 성질. Java에서 다형성을 구현할 수 있는 대표적으로 Overriding과 Overloading이 있다.</p><h3 id="Overriding"><a href="#Overriding" class="headerlink" title="Overriding"></a>Overriding</h3><p>임의의 클래스가 다른 클래스를 상속 받거나 인터페이스를 구현했을 때, 상위 클래스 또는 인터페이스에 정의되어 있는 메소드를 재정의 하여 사용하는 것이다. 메소드 호출 시 재정의되어 있지 않다면 상위 클래스의 메소드가 호출된다. (인터페이스는 오버라이딩이 강제된다.)</p><h3 id="Overloading"><a href="#Overloading" class="headerlink" title="Overloading"></a>Overloading</h3><p>메소드에 주어진 인자(parameter)에 따라 동작을 다르게 구현할 수 있다. 코드의 중복이 줄어들고, 가독성이 늘어난다. 반환 형(return type)은 관계가 없지만, 인자의 개수, 인자의 타입에 따라 다르게 구현할 수 있다.</p><h2 id="상속"><a href="#상속" class="headerlink" title="상속"></a>상속</h2><p>부모의 형질을 이어받는다는 의미로, 부모 클래스의 속성과 메소드를 그대로 활용할 수 있다. 여기에 더해 새로운 속성과 메소드를 추가할 수 있으며 같은 메소드라 하더라도 오버라이딩(Overriding)을 통하여 재정의하여 다르게 동작하게끔 할 수 있다. 손쉽게 클래스를 재활용할 수 있으며, 부모가 같은 클래스들을 동시에 처리하기 용이하다.</p><h2 id="클래스-class"><a href="#클래스-class" class="headerlink" title="클래스(class)"></a>클래스(class)</h2><p>객체를 만들기 위해 상태(field)와 행위(method)를 정의한 틀.</p><h2 id="메시지"><a href="#메시지" class="headerlink" title="메시지"></a>메시지</h2><p>객체지향적으로 구현된 프로그램은 객체들끼리의 메시지를 주고받고 상호작용하며 동작한다. 코드적으로는 임의의 객체에게 인자(parameter)를 전달하여 메소드를 호출하며 반환값(return value)을 받아 처리를 한다.</p><h3 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h3><ul><li><a href="https://github.com/JaeYeopHan/Interview_Question_for_Beginner/tree/master/Development_common_sense#object-oriented-programming" target="_blank" rel="noopener">https://github.com/JaeYeopHan/Interview_Question_for_Beginner/tree/master/Development_common_sense#object-oriented-programming</a></li><li><a href="https://ko.wikipedia.org/wiki/객체_지향_프로그래밍" target="_blank" rel="noopener">https://ko.wikipedia.org/wiki/객체_지향_프로그래밍</a></li><li><a href="http://asfirstalways.tistory.com/177" target="_blank" rel="noopener">http://asfirstalways.tistory.com/177</a></li></ul>]]></content>
      
      <categories>
          
          <category> Study </category>
          
      </categories>
      
      
        <tags>
            
            <tag> OOP </tag>
            
            <tag> Interview </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Cloud Computing이란?</title>
      <link href="/Cloud-Computing/"/>
      <url>/Cloud-Computing/</url>
      <content type="html"><![CDATA[<p><img src="../post_resources/2018-09-11/1_title.jpg" alt=""></p><h1 id="개요"><a href="#개요" class="headerlink" title="개요"></a>개요</h1><ol><li>클라우드 컴퓨팅이란?</li><li>클라우드 컴퓨팅의 등장배경</li><li>클라우드 컴퓨팅의 정의</li><li>클라우드 컴퓨팅의 특징</li><li>클라우드 컴퓨팅 서비스 모델</li><li>클라우드 컴퓨팅의 장-단점</li><li>클라우드 안정성과 신뢰성</li><li>클라우드 도입</li></ol><h1 id="1-클라우드-컴퓨팅이란"><a href="#1-클라우드-컴퓨팅이란" class="headerlink" title="1. 클라우드 컴퓨팅이란?"></a>1. 클라우드 컴퓨팅이란?</h1><ul><li>인터넷 ‘너머’에 존재하는 클라우드 사업자의 컴퓨터에서 정보처리를 하는 서비스</li><li>특정 기술이 아닌, <u>사고 방식</u> 또는 <u>개념(모델)</u><blockquote><ol><li><strong>초기 투자</strong>나 <strong>장기 계약</strong> 없이</li><li><strong>인터넷</strong>을 통해 <strong>IT 리소스</strong>와 <strong>애플리케이션</strong>을</li><li><strong>원할 때 언제든지(On-demand)</strong> 사용할 수 있고</li><li><strong>사용한 만큼</strong> 요금을 내는 서비스</li></ol></blockquote></li></ul><h1 id="2-클라우드-컴퓨팅의-등장배경"><a href="#2-클라우드-컴퓨팅의-등장배경" class="headerlink" title="2. 클라우드 컴퓨팅의 등장배경"></a>2. 클라우드 컴퓨팅의 등장배경</h1><h2 id="정보처리-시스템의-흐름"><a href="#정보처리-시스템의-흐름" class="headerlink" title="정보처리 시스템의 흐름"></a>정보처리 시스템의 흐름</h2><ul><li>메인프레임 - 1980년대</li><li>분산형 클라이언트 서버 모델- 1990년대</li><li>사내 인트라넷 → 서버에 집중 - 2000년대</li><li>클라우드 컴퓨팅 - 2010년대<ul><li>전 세계에 분산 배치된 서버 리소스를 <u>필요한 때</u> <u>필요한 만큼</u> 사용</li></ul></li></ul><h2 id="정보처리-시스템의-흐름-1"><a href="#정보처리-시스템의-흐름-1" class="headerlink" title="정보처리 시스템의 흐름"></a>정보처리 시스템의 흐름</h2><ul><li>CPU 고속화</li><li>가상화 기술 및 분산 처리 기술</li><li>빠르고 저렴한 네트워크</li><li>거대해진 데이터 센터 (delf: 클라우드 서비스에 종속?)</li><li>사용자(기업) - IT 투자 비용 절감</li><li>사업자(클라우드 서비스 제공자) - 지속적 매출</li></ul><h1 id="3-클라우드-정의"><a href="#3-클라우드-정의" class="headerlink" title="3. 클라우드 정의"></a>3. 클라우드 정의</h1><p>NIST (미국 국립 표준 기술연구소) 정의 - <a href="http://www.ipa.go.jp/files/000025366.pdf" target="_blank" rel="noopener">www.ipa.go.jp/files/000025366.pdf</a></p><blockquote><p>공유 구성이 가능한 컴퓨팅 리소스의 통합을 통해 어디서나 간편하게, 요청에 따라 네트워크를 통해 접근하는 것을 가능하게 하는 모델. 이는 최소한의 이용 절차 또는 서비스 공급자의 상호 작용을 통해, 신속히 할당되어 제공된다.</p></blockquote><h1 id="4-클라우드-특징"><a href="#4-클라우드-특징" class="headerlink" title="4. 클라우드 특징"></a>4. 클라우드 특징</h1><ul><li>주문형 셀프 서비스 - 사용자 스스로 개별 관리</li><li>광범위한 네트워크 접속</li><li>리소스 공유 (delf: 가상화 기술)</li><li>신속한 확장성 - Scale Up/Down</li><li>측정 가능한 서비스 - 종량제</li></ul><h1 id="5-클라우드-서비스-모델"><a href="#5-클라우드-서비스-모델" class="headerlink" title="5. 클라우드 서비스 모델"></a>5. 클라우드 서비스 모델</h1><ul><li>IaaS (Infrastructure as a Service)</li><li>Paas (Platform as a Service)</li><li>Saas (Software as a Service)</li></ul><p><img src="../post_resources/2018-09-11/cloudmodel.png" alt=""><br>참고: <a href="https://www.ibm.com/cloud/learn/iaas-paas-saas" target="_blank" rel="noopener">https://www.ibm.com/cloud/learn/iaas-paas-saas</a>   </p><h2 id="IaaS-Infrastructure-as-a-Service"><a href="#IaaS-Infrastructure-as-a-Service" class="headerlink" title="IaaS (Infrastructure as a Service)"></a>IaaS (Infrastructure as a Service)</h2><ul><li>사업자는 사용자에게 pay-as-you-go access 제공</li><li>Storage, Networking, Servers, …</li></ul><p><img src="../post_resources/2018-09-11/infrastructure-as-a-service-iaas.jpg" alt=""></p><h2 id="PaaS-Platform-as-a-Service"><a href="#PaaS-Platform-as-a-Service" class="headerlink" title="PaaS (Platform as a Service)"></a>PaaS (Platform as a Service)</h2><ul><li>사업자는 Cloud-based environment + Infrastructure 제공</li><li>사용자는 Application 개발</li><li>Java, PHP, Ruby 등의 프로그래밍 언어를 지원하는 애플리케이션 실행 환경이나 데이터베이스 등이 미리 준비되어 있음</li><li>개발 및 테스트에 큰 처리 능력이 필요한 경우</li><li>자사에서 운영 중인 애플리케이션의 최대 부하를 분산 처리할 때</li><li>IoT 데이터를 효율적으로 수집하여 처리하는 플랫폼</li><li>Force.com</li></ul><p><img src="../post_resources/2018-09-11/platform-as-a-service-paas.jpg" alt=""></p><h2 id="SaaS-Software-as-a-Service"><a href="#SaaS-Software-as-a-Service" class="headerlink" title="SaaS (Software as a Service)"></a>SaaS (Software as a Service)</h2><ul><li>사업자는 사용자에게 software/application 제공</li><li>사용자는 subscrible를 하고 web 또는 API를 통해 access</li></ul><p><img src="../post_resources/2018-09-11/software-as-a-service-saas.jpg" alt=""></p><h2 id="클라우드-서비스-모델-참고-from-MS"><a href="#클라우드-서비스-모델-참고-from-MS" class="headerlink" title="클라우드 서비스 모델 참고 - from MS"></a>클라우드 서비스 모델 참고 - from MS</h2><ul><li><a href="https://azure.microsoft.com/ko-kr/overview/what-is-iaas/" target="_blank" rel="noopener">MS Azure IaaS란?</a></li><li><a href="https://azure.microsoft.com/ko-kr/overview/what-is-paas/" target="_blank" rel="noopener">MS Azure PaaS란?</a></li><li><a href="https://azure.microsoft.com/ko-kr/overview/what-is-saas/" target="_blank" rel="noopener">MS Azure SaaS란?</a></li></ul><h3 id="Cloud-Service-⟺︎-On-premise"><a href="#Cloud-Service-⟺︎-On-premise" class="headerlink" title="Cloud Service ⟺︎ On-premise"></a>Cloud Service ⟺︎ On-premise</h3><ul><li>회사 내에 자체적으로 데이터 센터를 보유</li><li>시스템 구축, 운용까지 직접 수행하는 형태</li></ul><h1 id="6-1-클라우드-컴퓨팅의-장점"><a href="#6-1-클라우드-컴퓨팅의-장점" class="headerlink" title="6-1. 클라우드 컴퓨팅의 장점"></a>6-1. 클라우드 컴퓨팅의 장점</h1><ul><li><strong>경제성</strong>: 사용하고자 하는 기간만, 소프트웨어/데이터를 클라우드에서 통합 관리</li><li><strong>유연성</strong>: 리소스를 필요할 때, 필요한 만큼 확장/축소 가능</li><li><strong>가용성</strong>: 장애 발생시 계속 사용 가능</li><li>빠른 구축 속도</li><li>손쉬운 글로벌 서비스(ex. 넷마블의 해외 서바스)</li><li>강력한 보안</li></ul><h1 id="6-2-클라우드-컴퓨팅의-단점"><a href="#6-2-클라우드-컴퓨팅의-단점" class="headerlink" title="6-2. 클라우드 컴퓨팅의 단점"></a>6-2. 클라우드 컴퓨팅의 단점</h1><ul><li>생각보다 비싼 비용</li><li>점점 커지는 클라우드 의존성</li><li>데이터 보관의 불안함</li></ul><h1 id="클라우드-이용-모델"><a href="#클라우드-이용-모델" class="headerlink" title="클라우드 이용 모델"></a>클라우드 이용 모델</h1><ul><li>Deployment model</li><li>Private cloud</li><li>Community cloud</li><li>Public cloud</li><li>Hybrid cloud</li></ul><h2 id="Private-cloud"><a href="#Private-cloud" class="headerlink" title="Private cloud"></a>Private cloud</h2><ul><li>독점적으로 사용되는 클라우드 컴퓨팅 리소스</li><li>클라우드 서비스 사용자 또는 사업자의 데이터 센터에 구축한 자사 전용 환경</li><li>서비스와 인프라가 개인/기업네트워크에서 유지 관리 됨</li></ul><h2 id="Community-cloud"><a href="#Community-cloud" class="headerlink" title="Community cloud"></a>Community cloud</h2><ul><li>공통의 목적을 가진 기업/조직들이 클라우드 시스템을 형성하여 데이터 센터에서 <strong>공동 운영</strong>하는 형태</li></ul><h2 id="Public-cloud"><a href="#Public-cloud" class="headerlink" title="Public cloud"></a>Public cloud</h2><ul><li>클라우드 사업자가 시스템 구축</li><li>네트워크를 통해 기업, 개인에게 서비스 제공</li><li>기업/개인 방화벽 외부에 구축됨</li></ul><h2 id="Hybrid-cloud"><a href="#Hybrid-cloud" class="headerlink" title="Hybrid cloud"></a>Hybrid cloud</h2><ul><li>Public, Private, Community 서비스들과 On-premise 시스템을 연계시켜 활용하는 시스템</li></ul><h3 id="Private-cloud-종류"><a href="#Private-cloud-종류" class="headerlink" title="Private cloud 종류"></a>Private cloud 종류</h3><ul><li>On-premise private cloud<ul><li>자사 전용 클라우드 환경 구축, 운용</li><li>자체적인 보안정책 → 강력한 보안 환경 부담</li></ul></li><li>Hosted private cloud<ul><li>클라우드 사업자가 기업 사용자별로 클라우드 환경 제공</li><li>기업 전용 클라우드 환경 구축 → 비용 지불</li></ul></li></ul><p><img src="../post_resources/2018-09-11/kind-of-cloud-model.png" alt=""></p><h1 id="클라우드의-안정성과-신뢰성"><a href="#클라우드의-안정성과-신뢰성" class="headerlink" title="클라우드의 안정성과 신뢰성"></a>클라우드의 안정성과 신뢰성</h1><ul><li>클라우드 리스크</li><li>장비 고장 리스크</li><li>재해, 운영자의 조작 실수 등의 리스크</li><li>통신 도청 리스크</li><li>중간자 공격</li><li>스푸핑</li><li>클라우드 사업자의 파산 또는 서비스 중단<br>…<h2 id="클라우드의-보안-거버넌스"><a href="#클라우드의-보안-거버넌스" class="headerlink" title="클라우드의 보안 거버넌스"></a>클라우드의 보안 거버넌스</h2></li><li>기업 경영진이 클라우드를 이용할 때의 위험을 주체적이고 적절하게 관리하기 위한 구조를 구축하고 운용하는 것</li><li>보안 등의 리스크를 모두 통제할 수 없다 → 클라우드 서비스의 연속성 리스크</li></ul><h1 id="8-클라우드-도입"><a href="#8-클라우드-도입" class="headerlink" title="8. 클라우드 도입"></a>8. 클라우드 도입</h1><h2 id="중소기업의-클라우드-도입"><a href="#중소기업의-클라우드-도입" class="headerlink" title="중소기업의 클라우드 도입"></a>중소기업의 클라우드 도입</h2><ul><li>중소기업의 IT 활용 부진의 요인 - 비용, 인재의 부족</li><li>클라우드 도입의 장점: 기업의 가치 창출, 성장에 대비</li><li>정보 시스템 담당자<ul><li>비용 절약</li><li>시장 환경 변화에 따라 유연하게 시스템을 변화시킬 수 있음</li></ul></li><li>경영진<ul><li>IT에 투자하는 경영 자원의 최소화</li><li>핵심 역량에 경영 자원 집중 가능</li></ul></li></ul><h2 id="대기업의-클라우드-도입"><a href="#대기업의-클라우드-도입" class="headerlink" title="대기업의 클라우드 도입"></a>대기업의 클라우드 도입</h2><ul><li>세계 시장 진출시 손쉬운 글로벌화</li><li>글로벌하게 전개할 수 있는 효율적인 업무 프로세스 구조 구축</li><li>신속한 시스템 도입 및 운영으로부터의 해방</li></ul>]]></content>
      
      <categories>
          
          <category> Study </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Cloud </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Java의 Comparable과 Comparator</title>
      <link href="/Comparable-and-Comparator/"/>
      <url>/Comparable-and-Comparator/</url>
      <content type="html"><![CDATA[<hr><!-- ![](../post_resources/2018-09-08/1_title.png){: width="100"){: .center} --><p><img src="../post_resources/2018-09-08/1_title.png" width="400"></p><h1 id="개요"><a href="#개요" class="headerlink" title="개요"></a>개요</h1><ol><li>배열 안의 요소 정렬</li><li>객체들의 정렬<ul><li><code>Comparable</code> interface</li><li><code>Comparator</code> interface</li></ul></li><li>예제</li></ol><h1 id="1-배열의-안의-요소-정렬"><a href="#1-배열의-안의-요소-정렬" class="headerlink" title="1. 배열의 안의 요소 정렬"></a>1. 배열의 안의 요소 정렬</h1><p>배열 안의 요소는 Java API에서 제공하는 <code>sort()</code>메서드를 이용하면 쉽게 정렬이 가능합니다.<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span>[] nums = &#123;<span class="number">4</span>, <span class="number">1</span>, <span class="number">3</span>, <span class="number">2</span>, <span class="number">5</span>&#125;;</span><br><span class="line">Arrays.sort(nums); <span class="comment">// 결과: 1, 2, 3, 4, 5</span></span><br><span class="line"></span><br><span class="line">String[] strs  = &#123;<span class="string">"D"</span>, <span class="string">"A"</span>, <span class="string">"B"</span>, <span class="string">"E"</span>, <span class="string">"C"</span>&#125;;</span><br><span class="line">Arrays.sort(strs); <span class="comment">// 결과: "A", "B", "C", "D", "E"</span></span><br></pre></td></tr></table></figure></p><p>이렇게 정렬이 가능한 이유는 각 요소를 <strong>비교</strong>할 수 있기 때문입니다. 1보다는 2가 크고, A보다는 B가 크죠.</p><p>하지만 아래와 같은 <code>Student</code> 인스턴스가 여러게 있다면, 과연 어떤게 <em>‘먼저’</em> 일까요?<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Student</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> String name;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span> age;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h1 id="2-객체들의-정렬"><a href="#2-객체들의-정렬" class="headerlink" title="2. 객체들의 정렬"></a>2. 객체들의 정렬</h1><p>사용자가 생성한 임의의 객체들을 정렬하기 위해서는 <strong>기준</strong>이 필요합니다. 즉 객체의 <strong>비교</strong>가 가능하다면 정렬을 할 수 있게됩니다.<br>어떤게 더 큰지, 어떤게 더 먼저인지 비교가 가능하다면, 그 기준에 따라 정렬이 가능하죠.</p><h2 id="Comparable-interface"><a href="#Comparable-interface" class="headerlink" title="Comparable interface"></a><code>Comparable</code> interface</h2><p>그 <strong>기준</strong>을 정의하기 위해서는 해당 class에 <code>Comparable</code> interface를 구현현하는 방법 이 있습니다. <code>CompareTo()</code>메소드를 오버라이드 하여 인스턴스에 대하여 비교 기준을 정의해야 합니다.</p><blockquote><p><u><code>Comparable</code>은 정렬 수행시 기본적으로 적용되는 정렬 기준이 되는 메서드를 정의해 놓는 인터페이스</u>입니다. </p></blockquote><p>사실, 위에서 <code>Arrays</code>를 이용하여 정렬한 배열안의 요소(객체)를 포함한 대부분의 Java의 기본 자료형들은 <code>Comparable</code> interface를 구현하고 있습니다.  </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Integer class</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">Integer</span> <span class="keyword">extends</span> <span class="title">Number</span> <span class="keyword">implements</span> <span class="title">Comparable</span>&lt;<span class="title">Integer</span>&gt; </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// String class</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">String</span></span></span><br><span class="line"><span class="class">    <span class="keyword">implements</span> <span class="title">java</span>.<span class="title">io</span>.<span class="title">Serializable</span>, <span class="title">Comparable</span>&lt;<span class="title">String</span>&gt;, <span class="title">CharSequence</span> </span>&#123;</span><br><span class="line">        ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>Comparable</code> interface를 구현하여 <code>Student</code>의 객체들을 나이(age)순으로 정렬하고자 한다면, 다음과 같이 정의할 수 있습니다.<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Student</span> <span class="keyword">implements</span> <span class="title">Comparable</span>&lt;<span class="title">Student</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> String name;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span> age;</span><br><span class="line">    ...</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compareTo</span><span class="params">(Student o)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> Integer.compare(<span class="keyword">this</span>.age, o.age);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><code>CompareTo()</code>의 반환값이 양수라면 내부 정렬 알고리즘에서 두 요소를 비교할 때 자리를 바꾸고, 0이나 음수라면 바꾸지 않습니다.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">Student[] arr = <span class="keyword">new</span> Student[<span class="number">5</span>];</span><br><span class="line">arr[<span class="number">0</span>] = <span class="keyword">new</span> Student(<span class="string">"A"</span>, <span class="number">26</span>);</span><br><span class="line">arr[<span class="number">1</span>] = <span class="keyword">new</span> Student(<span class="string">"B"</span>, <span class="number">27</span>);</span><br><span class="line">arr[<span class="number">2</span>] = <span class="keyword">new</span> Student(<span class="string">"C"</span>, <span class="number">27</span>);</span><br><span class="line">arr[<span class="number">3</span>] = <span class="keyword">new</span> Student(<span class="string">"D"</span>, <span class="number">21</span>);</span><br><span class="line">arr[<span class="number">4</span>] = <span class="keyword">new</span> Student(<span class="string">"E"</span>, <span class="number">20</span>);</span><br><span class="line"></span><br><span class="line">List&lt;Student&gt; students = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"><span class="keyword">for</span> (Student student : arr) </span><br><span class="line">    students.add(student);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 기본 배열에서의 정렬</span></span><br><span class="line">Arrays.sort(arr); <span class="comment">// 결과: E(20), D(21), B(27), A(26), C(27)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// List Collection에서의 정렬</span></span><br><span class="line">Collections.sort(students); <span class="comment">// 결과: E(20), D(21), B(27), A(26), C(27)</span></span><br></pre></td></tr></table></figure><h2 id="Comparator-interface"><a href="#Comparator-interface" class="headerlink" title="Comparator interface"></a><code>Comparator</code> interface</h2><p>그렇다면 <code>Student</code> 객체들을 <em>이름 순</em>으로 정렬하고 싶다면? <em>나이 내림차순</em>으로 정리하고 싶다면 어떡할까요?<br>정렬할 때 마다 <code>Student</code> class의 코드를 수정해야할까요?</p><p>이럴 때 쓰이는 것이 바로 <code>Comparator</code> interface입니다.  </p><blockquote><p><code>Comparator</code>는 <u>기본 정렬 기준(<code>Comparable</code>을 구현하여 정의한 기준)과는 다른 방식으로 정렬하고 싶을 때 사용하는 인터페이스</u>입니다. </p></blockquote><p>다른 기준의 정렬 조건을 정의하기 위해선 <code>Comparator</code>를 interface를 구현하고 <code>compare()</code>메서드를 작성해야 합니다. 여기서는 간단하게 익명 클래스(Anonymouse class)로 구현하겠습니다.<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">Student[] arr = <span class="keyword">new</span> Student[<span class="number">5</span>];</span><br><span class="line">arr[<span class="number">0</span>] = <span class="keyword">new</span> Student(<span class="string">"A"</span>, <span class="number">26</span>);</span><br><span class="line">arr[<span class="number">1</span>] = <span class="keyword">new</span> Student(<span class="string">"B"</span>, <span class="number">27</span>);</span><br><span class="line">arr[<span class="number">2</span>] = <span class="keyword">new</span> Student(<span class="string">"C"</span>, <span class="number">27</span>);</span><br><span class="line">arr[<span class="number">3</span>] = <span class="keyword">new</span> Student(<span class="string">"D"</span>, <span class="number">21</span>);</span><br><span class="line">arr[<span class="number">4</span>] = <span class="keyword">new</span> Student(<span class="string">"E"</span>, <span class="number">20</span>);</span><br><span class="line"></span><br><span class="line">List&lt;Student&gt; students = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"><span class="keyword">for</span> (Student student : arr) </span><br><span class="line">    students.add(student);</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Comparator 익명클래스 정의 */</span></span><br><span class="line">Comparator&lt;Student&gt; descNameComparator = <span class="keyword">new</span> Comparator&lt;Student&gt;() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compare</span><span class="params">(Student s1, Student s2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> s2.name.compareTo(s1.name); <span class="comment">// 이름에 대하여 내림차순</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// 기본 배열에서의 정렬</span></span><br><span class="line">Arrays.sort(arr, descNameComparator); <span class="comment">// 결과: E(20), D(21), C(27), B(24), A(26)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// List Collection에서의 정렬</span></span><br><span class="line">Collections.sort(stdents, descNameComparator); <span class="comment">// 결과: E(20), D(21), C(27), B(24), A(26)</span></span><br></pre></td></tr></table></figure></p><p>이름을 내림차순으로 정렬하기 위하여 String의 비교 값을 출력하였습니다. 이와 같이 <code>Comparator</code> 인터페이스를 구현하면, 임의의 사용자 객체에 대하여 여러 종류의 기준으로 정렬이 가능합니다.</p><p>조건문을 통해 <code>compare()</code>메서드의 반환값을 제어해 준다면 정렬 기준을 중복하여 적용할 수 있습니다. 이는 <code>Comparable</code> 인터페이스의 <code>compareTo()</code>메서드도 마찬가지입니다.<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 나이 역순으로 정렬. 나이가 같다면 이름순으로 정렬.</span></span><br><span class="line">Comparator&lt;Student&gt; myComparator = <span class="keyword">new</span> Comparator&lt;Student&gt;() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compare</span><span class="params">(Student s1, Student s2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(s1.age == s2.age) &#123;</span><br><span class="line">            <span class="keyword">return</span> s1.name.compareTo(s2.name);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> Integer.compare(s2.age, s1.age);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><h1 id="3-예제"><a href="#3-예제" class="headerlink" title="3. 예제"></a>3. 예제</h1><p>위 설명을 기반으로 한 예제 코드입니다.<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String args[])</span> </span>&#123;</span><br><span class="line">        <span class="comment">// Student 배열 인스턴스 생성</span></span><br><span class="line">        Student[] arr = <span class="keyword">new</span> Student[<span class="number">5</span>];</span><br><span class="line">        arr[<span class="number">0</span>] = <span class="keyword">new</span> Student(<span class="string">"A"</span>, <span class="number">26</span>);</span><br><span class="line">        arr[<span class="number">1</span>] = <span class="keyword">new</span> Student(<span class="string">"B"</span>, <span class="number">27</span>);</span><br><span class="line">        arr[<span class="number">2</span>] = <span class="keyword">new</span> Student(<span class="string">"C"</span>, <span class="number">27</span>);</span><br><span class="line">        arr[<span class="number">3</span>] = <span class="keyword">new</span> Student(<span class="string">"D"</span>, <span class="number">21</span>);</span><br><span class="line">        arr[<span class="number">4</span>] = <span class="keyword">new</span> Student(<span class="string">"E"</span>, <span class="number">20</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Student List Collection 인스턴스 생성</span></span><br><span class="line">        List&lt;Student&gt; students = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (Student student : arr)</span><br><span class="line">            students.add(student);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 기본 배열에서의 정렬(Comparable interface)</span></span><br><span class="line">        Arrays.sort(arr);</span><br><span class="line">        System.out.println(Arrays.asList(arr)); <span class="comment">// E(20), D(21), B(27), A(26), C(27)</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// List Collection에서의 정렬(Comparable interface)</span></span><br><span class="line">        Collections.sort(students);</span><br><span class="line">        System.out.println(students); <span class="comment">// E(20), D(21), B(27), A(26), C(27)</span></span><br><span class="line"></span><br><span class="line">        System.out.println();</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* Comparator 익명클래스 정의 */</span></span><br><span class="line">        Comparator&lt;Student&gt; descNameComparator = <span class="keyword">new</span> Comparator&lt;Student&gt;() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compare</span><span class="params">(Student s1, Student s2)</span> </span>&#123;</span><br><span class="line">                <span class="keyword">return</span> s2.name.compareTo(s1.name); <span class="comment">// 이름에 대하여 내림차순</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 기본 배열에서의 정렬(Comparator interface)</span></span><br><span class="line">        Arrays.sort(arr, descNameComparator);</span><br><span class="line">        System.out.println(Arrays.asList(arr)); <span class="comment">// E(20), D(21), C(27), B(27), A(26)</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// List Collection에서의 정렬(Comparator interface)</span></span><br><span class="line">        Collections.sort(students, descNameComparator);</span><br><span class="line">        System.out.println(students); <span class="comment">// E(20), D(21), C(27), B(27), A(26)</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Student</span> <span class="keyword">implements</span> <span class="title">Comparable</span>&lt;<span class="title">Student</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> String name;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span> age;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Student</span><span class="params">(String name, <span class="keyword">int</span> age)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">        <span class="keyword">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compareTo</span><span class="params">(Student o)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> Integer.compare(<span class="keyword">this</span>.age, o.age); <span class="comment">// 나이에 대하여 오름차순</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> name + <span class="string">"("</span> + age + <span class="string">")"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h3><ul><li><a href="http://hochulshin.com/java-comparable-comparator/" target="_blank" rel="noopener">http://hochulshin.com/java-comparable-comparator/</a></li><li><a href="http://cwondev.tistory.com/15" target="_blank" rel="noopener">http://cwondev.tistory.com/15</a></li><li><a href="https://docs.oracle.com/javase/8/docs/api/java/lang/Comparable.html" target="_blank" rel="noopener">https://docs.oracle.com/javase/8/docs/api/java/lang/Comparable.html</a></li><li><a href="https://docs.oracle.com/javase/8/docs/api/java/util/Comparator.html" target="_blank" rel="noopener">https://docs.oracle.com/javase/8/docs/api/java/util/Comparator.html</a></li></ul>]]></content>
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
  
  
</search>
