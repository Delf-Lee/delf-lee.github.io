<!DOCTYPE html><html lang="ko"><head><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black-translucent" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="description"><title>String vs StringBuilder vs StringBuffer | Delf's blog</title><link rel="stylesheet" type="text/css" href="/css/style.css?v=0.0.0"><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/normalize/8.0.0/normalize.min.css"><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/pure/1.0.0/pure-min.css"><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/pure/1.0.0/grids-responsive-min.css"><link rel="stylesheet" href="//cdn.bootcss.com/font-awesome/4.7.0/css/font-awesome.min.css"><script type="text/javascript" src="//cdn.bootcss.com/jquery/3.3.1/jquery.min.js"></script><link rel="Shortcut Icon" type="image/x-icon" href="/favicon.ico"><link rel="apple-touch-icon" href="/apple-touch-icon.png"><link rel="apple-touch-icon-precomposed" href="/apple-touch-icon.png"><link rel="alternate" type="application/atom+xml" href="/atom.xml"><script>(function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
(i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
})(window,document,'script','https://www.google-analytics.com/analytics.js','ga');
ga('create','UA-125726661-1','auto');ga('send','pageview');
</script></head><body><div class="body_container"><div id="header"><div class="site-name"><h1 class="hidden">String vs StringBuilder vs StringBuffer</h1><a id="logo" href="/.">Delf's blog</a><p class="description"></p></div><div id="nav-menu"><a class="current" href="/."><i class="fa fa-home"> 홈</i></a><a href="/archives/"><i class="fa fa-archive"> 아카이브</i></a><a href="/about/"><i class="fa fa-user"> 소개</i></a><a href="/atom.xml"><i class="fa fa-rss"> RSS</i></a></div></div><div class="pure-g" id="layout"><div class="pure-u-1 pure-u-md-3-4"><div class="content_container"><div class="post"><h1 class="post-title">String vs StringBuilder vs StringBuffer</h1><div class="post-meta">2018-10-30<span>　　|　　</span><span class="tags"><a href="/tags/java/">Java</a></span><span>　　|　　</span><span class="category"><a href="/categories/study/">Study</a></span></div><div class="post-content"><p><img src="/post_resources/2018-10-30/title.png" alt=""><br>세 클래스의 공통점은 모두 문자열(String)을 저장하고 관리하는 클래스라는 것입니다.</p>
<h1 id="String"><a href="#String" class="headerlink" title="String"></a><code>String</code></h1><p><code>String</code>클래스는 immutable(불변)하다는 특성이 있습니다. <code>String</code>클래스의 문자열을 저장하는 <code>char[]</code>을 보면 <code>final</code>로 선언되어 있다는 것을 확인할 수 있습니다.<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">String</span></span></span><br><span class="line"><span class="class">    <span class="keyword">implements</span> <span class="title">java</span>.<span class="title">io</span>.<span class="title">Serializable</span>, <span class="title">Comparable</span>&lt;<span class="title">String</span>&gt;, <span class="title">CharSequence</span> </span>&#123;</span><br><span class="line">    <span class="comment">/** The value is used for character storage. */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">char</span> value[];</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>그 때문에, 한번 할당한 문자열을 변경하는 것은 불가능하며, 더하기 연산을 하여 붙일 시 새로운 객체가 생성되어 재할당 됩니다.</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">String s = <span class="string">"hello"</span>;</span><br><span class="line">System.out.println(s.hashCode()); <span class="comment">// 99162322</span></span><br><span class="line">s += <span class="string">" delf!"</span>;</span><br><span class="line">System.out.println(s.hashCode()); <span class="comment">// 1776255224</span></span><br></pre></td></tr></table></figure>
<!-- 208951, 1179 메모리 사용량 차이 -->
<p>반복적으로 문자열을 이어 붙이면 Heap 영역에 참조를 잃은 문자열 객체가 계속해서 쌓이게 됩니다. 물론 나중에 GC에 의해 수거가 되지만, 메모리 관리 측면에서 이러한 코드는 결코 좋다고 할 수 없습니다. 또한 계속해서 객체를 생성하기 때문에 연산 속도적인 측면에서도 뒤떨어집니다.</p>
<p>이러한 <code>String</code>의 성능 이슈를 개선하기 위해 JDK 1.5 이상에서는 컴파일 단계에서 내부적으로 <code>StringBuilder</code>로 변경되어 동작됩니다.</p>
<h1 id="StringBuilder"><a href="#StringBuilder" class="headerlink" title="StringBuilder"></a><code>StringBuilder</code></h1><p>반면 <code>StringBuilder</code>클래스는 mutable(가변) 합니다. 상속 받고있는 <code>AbstractStringBuilder</code> 클래스의 내부를 보면 변경 가능하도록 선언되어 있습니다.<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">AbstractStringBuilder</span> <span class="keyword">implements</span> <span class="title">Appendable</span>, <span class="title">CharSequence</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * The value is used for character storage.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">char</span>[] value;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><code>append()</code> 메소드를 호출하면, <code>char[]</code> 배열의 길이를 늘리고 같은 객체에 문자열을 더합니다. 아래의 코드를 보면 <code>append()</code> 호출 이후에도 <code>StringBuilder</code> 객체에 변함이 없음을 확인할 수 있습니다.<br><!-- 위의 `String` 클래스를 사용한 코드와 동일하게 동작하는 코드를 `StringBuilder` 클래스를 이용하여 구현하면 다음과 같습니다. --><br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">StringBuilder s = <span class="keyword">new</span> StringBuilder(<span class="string">"hello"</span>);</span><br><span class="line">System.out.println(s.hashCode()); <span class="comment">// 859417998</span></span><br><span class="line">s.append(<span class="string">" delf!"</span>);</span><br><span class="line">System.out.println(s.hashCode()); <span class="comment">// 859417998</span></span><br></pre></td></tr></table></figure></p>
<h2 id="String-vs-StringBuilder"><a href="#String-vs-StringBuilder" class="headerlink" title="String vs StringBuilder"></a><code>String</code> vs <code>StringBuilder</code></h2><p>위에서도 언급했듯이, <code>String</code>의 성능 이슈를 개선하기 위해 JDK 1.5 이상에서는 컴파일 단계에서 내부적으로 <code>StringBuilder</code>로 변경되어 동작됩니다.</p>
<p>예를들어 아래와 같이 <code>+</code> 연산자를 이용한 코드는<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">String outside = str1 + str2 ... + strN;</span><br></pre></td></tr></table></figure></p>
<p>내부적으로 다음과 같이 동작하게 됩니다.<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">String inside = <span class="keyword">new</span> StringBuilder(String.valueOf(str1)).append(str2).[...].apend(strN).toString();</span><br></pre></td></tr></table></figure></p>
<p><code>+</code>연산과 <code>append()</code>메소드의 실질적인 성능 차이는 거의 없습니다만, 아래와 같은 코드는 매 루프마다 <code>StringBuilder</code>객체가 생성되므로 기존(JDK 1.5 이하)의 <code>String</code>의 <code>+</code>연산과 같이 마찬가지로 불필요한 객체가 쌓이게 되고 성능에 악영향을 미칩니다.<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">100000</span>; i++) &#123;</span><br><span class="line">    string += value;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>때문에 어떠한 경우라도 반복문에서는 <code>String</code>의 <code>+</code> 연산은 피하는게 좋습니다.</p>
<blockquote>
<p>반복문에서의 <code>String</code>과 <code>StringBuilder</code>의 속도차이 실험 결과 약 만배의 속도 차이를 확인할 수 있었습니다. - <a href="https://gist.github.com/Delf-Lee/d38d05075d3c198f521dd4b2d126cd50" target="_blank" rel="noopener">code</a></p>
</blockquote>
<h1 id="StringBuffer"><a href="#StringBuffer" class="headerlink" title="StringBuffer"></a><code>StringBuffer</code></h1><p><code>StringBuffer</code>는 <code>synchronized</code>가 적용되어 멀티스레드 환경에서 Thread-safe하게 동작할 수 있습니다. 한마디로 동기화를 지원하는 <code>StringBuilder</code>라고 이해하시면 편합니다.<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// StringBuffer 클래스의 append 메소드</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> StringBuffer <span class="title">append</span><span class="params">(CharSequence s)</span> </span>&#123;</span><br><span class="line">    toStringCache = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">super</span>.append(s);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="StringBuilder-vs-StringBuffer"><a href="#StringBuilder-vs-StringBuffer" class="headerlink" title="StringBuilder vs StringBuffer"></a><code>StringBuilder</code> vs <code>StringBuffer</code></h2><p>하나의 <code>StringBuilder</code>객체와 <code>StringBuffer</code>객체에 10,000개의 스레드가 접근해서 <code>append()</code>를 수행히는 실험을 해봤습니다.<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AppendTest</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> StringBuilder builder = <span class="keyword">new</span> StringBuilder(<span class="string">""</span>);</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> StringBuffer buffer = <span class="keyword">new</span> StringBuffer(<span class="string">""</span>);</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* 1. StringBuilder에 문자열 붙이는 스레드 10000개 생성 */</span></span><br><span class="line">        Appenders[] appenders = <span class="keyword">new</span> Appenders[<span class="number">10</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; appenders.length; i++) &#123;</span><br><span class="line">            appenders[i] = <span class="keyword">new</span> Appenders(builder,<span class="number">10000</span>, <span class="string">"a"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (Appenders a : appenders) &#123; <span class="comment">// 스레드 시작</span></span><br><span class="line">            a.start(); <span class="comment">//10000개의 스레드가 하나의 StringBuilder에 append</span></span><br><span class="line">        &#125;</span><br><span class="line">        Thread.sleep(<span class="number">3000</span>); <span class="comment">// 3초 대기</span></span><br><span class="line">        System.out.println(builder.length());</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* 2. StringBuffer에 문자열 붙이는 스레드 10000개 생성 */</span></span><br><span class="line">        appenders = <span class="keyword">new</span> Appenders[<span class="number">10</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; appenders.length; i++) &#123; <span class="comment">// 스레드 10000개 생성</span></span><br><span class="line">            appenders[i] = <span class="keyword">new</span> Appenders(buffer,<span class="number">10000</span>, <span class="string">"a"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (Appenders a : appenders) &#123; <span class="comment">// 스레드 시작</span></span><br><span class="line">            a.start(); <span class="comment">// 10000개의 스레드가 하나의 StringBuffer에 append</span></span><br><span class="line">        &#125;</span><br><span class="line">        Thread.sleep(<span class="number">3000</span>); <span class="comment">// 3초 대기</span></span><br><span class="line">        System.out.println(buffer.length());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Appenders</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Appendable ap;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> cnt;</span><br><span class="line">    <span class="keyword">private</span> String s;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Appenders</span><span class="params">(Appendable ap, <span class="keyword">int</span> cnt, String s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.cnt = cnt;</span><br><span class="line">        <span class="keyword">this</span>.ap = ap;</span><br><span class="line">        <span class="keyword">this</span>.s = s;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (cnt-- &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                ap.append(s);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IOException e) &#123;&#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>실행 결과<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">93221</span> <span class="comment">// 매 실행 마다 결과가 다름.</span></span><br><span class="line"><span class="number">100000</span></span><br></pre></td></tr></table></figure></p>
<p>Thread-safe하지 않은 <code>StringBuilder</code>에 여러 스레드가 동시에 <code>append()</code>할 경우에, 기존 문자열 뒤 인덱스 값이 동기화되지 않아 중복된 장소에 여러 번 값을 덮어 쓰는 경우가 발생하고, 목표 횟수만큼 문자열이 추가되지 않게됩니다.</p>
<p>심지어 <code>char[]</code>의 버퍼를 늘리기 전에 문자 할당을 시도해서 <code>ArrayIndexOutOfBoundsException</code>이 발생하기도 하지요.</p>
<p>반면, <code>synchronized</code> 키워드를 지원하는 <code>StringBuffer</code>는 깔끔하게 목표 횟수만큼 문자열이 추가되었습니다.</p>
<h1 id="정리"><a href="#정리" class="headerlink" title="정리"></a>정리</h1><h3 id="String-1"><a href="#String-1" class="headerlink" title="String"></a><code>String</code></h3><ul>
<li>단순히 문자열을 참조하거나 탐색 및 검색이 잦을 때 좋습니다.</li>
</ul>
<h3 id="StringBuilder-1"><a href="#StringBuilder-1" class="headerlink" title="StringBuilder"></a><code>StringBuilder</code></h3><ul>
<li>런타임 때, 반복적인 문자열 추가 연산이 많을 때 좋습니다.</li>
<li>단일 스레드 환경이라면 <code>StringBuffer</code>보다 성능이 좋을 수 있습니다.</li>
</ul>
<h3 id="StringBuffer-1"><a href="#StringBuffer-1" class="headerlink" title="StringBuffer"></a><code>StringBuffer</code></h3><ul>
<li>멀티 스레드 환경에서 반복적인 추가 문자 추가 연산이 많을 때 좋습니다.</li>
</ul>
<h3 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h3><ul>
<li><a href="http://jeong-pro.tistory.com/85" target="_blank" rel="noopener">http://jeong-pro.tistory.com/85</a></li>
<li><a href="https://www.slipp.net/questions/271" target="_blank" rel="noopener">https://www.slipp.net/questions/271</a></li>
<li><a href="http://hackersstudy.tistory.com/12" target="_blank" rel="noopener">http://hackersstudy.tistory.com/12</a></li>
<li><a href="https://medium.com/@joongwon/string-%EC%9D%98-%EB%A9%94%EB%AA%A8%EB%A6%AC%EC%97%90-%EB%8C%80%ED%95%9C-%EA%B3%A0%EC%B0%B0-57af94cbb6bc" target="_blank" rel="noopener">https://medium.com/@joongwon/string-%EC%9D%98-%EB%A9%94%EB%AA%A8%EB%A6%AC%EC%97%90-%EB%8C%80%ED%95%9C-%EA%B3%A0%EC%B0%B0-57af94cbb6bc</a></li>
</ul>
</div><div class="post-nav"><a class="next" href="/post/raid/">RAID</a></div></div></div></div><div class="pure-u-1 pure-u-md-1-4"><div id="sidebar"><div class="widget"><div class="search-form"><input id="local-search-input" placeholder="Search" type="text" name="q" results="0"/><div id="local-search-result"></div></div></div><div class="widget"><div class="widget-title"><i class="fa fa-folder-o"> 카테고리</i></div><ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/study/">Study</a><span class="category-list-count">8</span></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-star-o"> 태그</i></div><div class="tagcloud"><a href="/tags/db/" style="font-size: 15px;">DB</a> <a href="/tags/cloud/" style="font-size: 15px;">Cloud</a> <a href="/tags/oop/" style="font-size: 15px;">OOP</a> <a href="/tags/interview/" style="font-size: 15px;">Interview</a> <a href="/tags/java/" style="font-size: 15px;">Java</a> <a href="/tags/os/" style="font-size: 15px;">OS</a> <a href="/tags/web/" style="font-size: 15px;">Web</a> <a href="/tags/http/" style="font-size: 15px;">HTTP</a> <a href="/tags/aws/" style="font-size: 15px;">AWS</a></div></div><div class="widget"><div class="widget-title"><i class="fa fa-file-o"> 과거</i></div><ul class="post-list"><li class="post-list-item"><a class="post-list-link" href="/post/string-stringbuilder-stringbuffer/">String vs StringBuilder vs StringBuffer</a></li><li class="post-list-item"><a class="post-list-link" href="/post/raid/">RAID</a></li><li class="post-list-item"><a class="post-list-link" href="/post/restful/">RESTful과 REST API</a></li><li class="post-list-item"><a class="post-list-link" href="/post/connection-pool/">Databese Connection Pool</a></li><li class="post-list-item"><a class="post-list-link" href="/post/java-generic/">제네릭(Generic)이란?</a></li><li class="post-list-item"><a class="post-list-link" href="/post/why-cloud-computing/">Cloud Computing를 사용하는 이유</a></li><li class="post-list-item"><a class="post-list-link" href="/post/object-oriented/">객체지향(Object-Oriented)이란?</a></li><li class="post-list-item"><a class="post-list-link" href="/post/cloud-computing/">Cloud Computing이란?</a></li><li class="post-list-item"><a class="post-list-link" href="/post/comparable-and-comparator/">Java의 Comparable과 Comparator</a></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-external-link"> 블로그롤</i></div><ul></ul><a href="https://github.com/Delf-Lee" title="Github" target="_blank">Github</a></div></div></div><div class="pure-u-1 pure-u-md-3-4"><div id="footer">Copyright © 2018 <a href="/." rel="nofollow">Delf's blog.</a> Powered by<a rel="nofollow" target="_blank" href="https://hexo.io"> Hexo.</a><a rel="nofollow" target="_blank" href="https://github.com/tufu9441/maupassant-hexo"> Theme</a> by<a rel="nofollow" target="_blank" href="https://github.com/pagecho"> Cho.</a></div></div></div><a class="show" id="rocket" href="#top"></a><script type="text/javascript" src="/js/totop.js?v=0.0.0" async></script><script type="text/javascript" src="//cdn.bootcss.com/fancybox/3.3.5/jquery.fancybox.min.js" async></script><script type="text/javascript" src="/js/fancybox.js?v=0.0.0" async></script><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/fancybox/3.3.5/jquery.fancybox.min.css"><script type="text/javascript" src="/js/search.js?v=0.0.0"></script><script>var search_path = 'sheearch.xml';
if (search_path.length == 0) {
   search_path = 'search.xml';
}
var path = '/' + search_path;
searchFunc(path, 'local-search-input', 'local-search-result');
</script><script type="text/javascript" src="/js/codeblock-resizer.js?v=0.0.0"></script><script type="text/javascript" src="/js/smartresize.js?v=0.0.0"></script></div></body></html>